



var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            var blueskyHttpClient;
            (function (blueskyHttpClient) {
                //TODO MGA document
                (function (EndpointType) {
                    /** Use current domain from which the app was loaded. */
                    EndpointType[EndpointType["ORIGIN"] = 0] = "ORIGIN";
                    /** Use CoreAPI url. By default, handles auth & userRole. */
                    EndpointType[EndpointType["CORE_API"] = 1] = "CORE_API";
                    /** Use MarketingAPI url. By default, ignores auth & userRole. */
                    EndpointType[EndpointType["MARKETING_API"] = 2] = "MARKETING_API";
                    /** Use QuoteWizard url of the current env. By default, ignores auth, session & userRole. */
                    EndpointType[EndpointType["QUOTE_WIZARD"] = 3] = "QUOTE_WIZARD";
                    /** Use OrderEntry url of the current env. By default, ignores auth, session & userRole. */
                    EndpointType[EndpointType["ORDER_ENTRY"] = 4] = "ORDER_ENTRY";
                    /** Use OrderTracking url of the current env. By default, ignores auth, session & userRole. */
                    EndpointType[EndpointType["ORDER_TRACKING"] = 5] = "ORDER_TRACKING";
                    /** External URL. By default, do nothing & pass it to $http service. */
                    EndpointType[EndpointType["EXTERNAL"] = 6] = "EXTERNAL";
                })(blueskyHttpClient.EndpointType || (blueskyHttpClient.EndpointType = {}));
                var EndpointType = blueskyHttpClient.EndpointType;
            })(blueskyHttpClient = models.blueskyHttpClient || (models.blueskyHttpClient = {}));
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));



var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            /**
             * Provider for the BlueskyHttpWrapper.
             * Enables per-consumer configuration of the http service to set custom configuration URL to fetch data from:
             *  - Client initial configuration URL from the origin the app was loaded from.
             *  - UserRole to use of already fetched from another place.
             */
            var BlueskyHttpWrapperProvider = (function () {
                function BlueskyHttpWrapperProvider() {
                    var _this = this;
                    //#region private properties
                    this.getClientConfigInitializationUrl = 'CoreApiAuth/GetCoreApiConfig'; // by default: TODO MGA change it in all OM apps ! not a meaningfull name.
                    this.selectedUserRole = null; // by default not-set.
                    //#endregion
                    // Provider's factory function
                    /* @ngInject */
                    this.$get = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster", function ($http, $window, $log, $q, $location, Upload, toaster) {
                        return new services.BlueskyHttpWrapper($http, $window, $log, $q, $location, Upload, toaster, _this.getClientConfigInitializationUrl, _this.selectedUserRole);
                    }];
                    this.$get.$inject = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                }
                //#endregion
                //#region public configuration methods
                BlueskyHttpWrapperProvider.prototype.setClientConfigURL = function (clientConfigUrlToUse) {
                    this.getClientConfigInitializationUrl = clientConfigUrlToUse || this.getClientConfigInitializationUrl;
                };
                BlueskyHttpWrapperProvider.prototype.setUserRoleToUse = function (userRole) {
                    this.selectedUserRole = userRole || null;
                };
                return BlueskyHttpWrapperProvider;
            }());
            services.BlueskyHttpWrapperProvider = BlueskyHttpWrapperProvider;
            angular.module('bluesky.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .provider('blueskyHttpWrapper', BlueskyHttpWrapperProvider);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var EndpointType = bluesky.core.models.blueskyHttpClient.EndpointType;
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            //TODO MGA: make this injectable // configurable in config phase
            var CORE_API_ENDPOINT_SUFFIX = 'api';
            var MARKETING_API_ENDPOINT_SUFFIX = 'api';
            var BlueskyHttpWrapper = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                BlueskyHttpWrapper.$inject = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster", "configInitializationURL", "selectedUserRole"];
                function BlueskyHttpWrapper($http, $window, $log, $q, $location, Upload, toaster, configInitializationURL, selectedUserRole) {
                    // 1 - fetch the configuration data necessary for this service to run from the provided endpoint
                    var _this = this;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    this.configInitializationURL = configInitializationURL;
                    this.selectedUserRole = selectedUserRole;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        // input validation
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        // set default config values and custom ones based on endpoints
                        config = config || {};
                        config.endpointType = config.endpointType || EndpointType.ORIGIN; // default value: if not specified, endpoint to use is supposed to be the origin. 
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        configFull.headers = config.headers || {};
                        // configure default config flags based on target endpoint
                        if (config.endpointType === EndpointType.CORE_API) {
                            // Reject explicitly wrong input configurations
                            if (config.disableXmlHttpRequestHeader ||
                                config.useCurrentUserRole === false ||
                                config.useCoreApiJwtAuthToken === false) {
                                _this.$log.warn("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - CoreAPI call intended with incompatible configuration options. Aborting ajax call.", config);
                                return null;
                            }
                            // config values for CoreAPI endpoint are different from default, so we must specify them.
                            config.disableXmlHttpRequestHeader = false;
                            config.useCoreApiJwtAuthToken = true;
                            config.useCurrentUserRole = true;
                        }
                        else if (config.endpointType === EndpointType.MARKETING_API ||
                            config.endpointType === EndpointType.ORIGIN ||
                            config.endpointType === EndpointType.QUOTE_WIZARD ||
                            config.endpointType === EndpointType.ORDER_ENTRY ||
                            config.endpointType === EndpointType.ORDER_TRACKING) {
                            // TODO MGA: provide more complete feedbacks on those specific endpoints ?
                            if (config.useCurrentUserRole ||
                                config.useCoreApiJwtAuthToken)
                                _this.$log.warn('[BlueskyHttpWrapper][configureHttpCall] - UserRole & JwtToken should not be provided for target endpoint. ');
                        }
                        else if (config.endpointType === EndpointType.EXTERNAL) {
                            config.disableXmlHttpRequestHeader = true; // do not add XmlHttpRequest if external Url by default: might create conflicts on certain servers. TODO MGA to confirm
                        }
                        else {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Unsupported endpointType provided: '" + EndpointType[config.endpointType] + "'. Aborting.");
                        }
                        //TODO MGA: set default values after endpoint-specific configurations
                        config.disableXmlHttpRequestHeader = config.disableXmlHttpRequestHeader || false; // default value is enabled (ajax calls on .NET endpoints).
                        config.useCurrentUserRole = config.useCurrentUserRole || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.useCoreApiJwtAuthToken = config.useCoreApiJwtAuthToken || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.disableToasterNotifications = config.disableToasterNotifications || false; //set default value for disableToasterNotifications to false as it's part of the normal behavior expected for this service.
                        // Try to build a valid url from input & endpointType.
                        configFull.url = _this.buildUrlFromContext(url, config.endpointType);
                        if (!configFull.url) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] - Unable to build url from urlInput '" + url + "' with endpointType '" + EndpointType[config.endpointType] + "'. Aborting ajax call.");
                            return null;
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        if (config.useCurrentUserRole) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig || !_this.blueskyAjaxClientConfig.currentUserRole) {
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without necessary userRole in blueskyAjaxClientConfig. Aborting.");
                                return null;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['OA-UserRole'] = _this.blueskyAjaxClientConfig.currentUserRole;
                        }
                        if (config.useCoreApiJwtAuthToken) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig || !_this.blueskyAjaxClientConfig.coreApiAuthToken) {
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without necessary jwtToken in blueskyAjaxClientConfig. Aborting.");
                                return null;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['Authorization'] = 'Bearer ' + _this.blueskyAjaxClientConfig.coreApiAuthToken;
                        }
                        //TODO MGA: OE specific code, to remove, or at least put in as config param
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (originalConfig) {
                        return function (httpPromise) {
                            if (!httpPromise) {
                                _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                                if (!originalConfig.disableToasterNotifications)
                                    _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                                return null;
                            }
                            //TODO MGA: reject if status != 2XX ?
                            //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                            //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                            //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                            //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                            //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                            //}
                            //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                            //TODO MGA: get full url of request
                            _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // return only the data expected for caller
                            return httpPromise.data;
                        };
                    };
                    /**
                     * Error handler
                     * TODO MGA: angular signatures indicates that parameter is rejection reason, not necessarily httpPromise: investigate & fix if necessary
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (originalConfig) {
                        return function (httpPromise) {
                            // We suppose in case of no response that the srv didn't send any response.
                            // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                            if (!httpPromise || !httpPromise.data) {
                                httpPromise.data = 'Server not responding';
                                httpPromise.status = 503;
                            }
                            if (!originalConfig.disableToasterNotifications) {
                                var contentType = httpPromise.headers('Content-Type');
                                //check contentType to try to display error message
                                if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                                    var message = ""; //default message
                                    //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                                    //if (response.data.ModelState) {
                                    //    //TODO MGA : handle this when well formatted server-side
                                    //} else
                                    if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                        message = httpPromise.data.Message;
                                    }
                                    else if (angular.isString(httpPromise.data)) {
                                        message = httpPromise.data;
                                    }
                                    //TODO MGA: handle more response codes gracefully.
                                    if (httpPromise.status === 404) {
                                        _this.toaster.warning('Not Found', message);
                                    }
                                    else {
                                        _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                                    }
                                }
                                else {
                                    _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                                }
                            }
                            //TODO MGA: get full url of request
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                            // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                            return _this.$q.reject(httpPromise);
                        };
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     * TODO MGA inversion of responsability: make this extensible so that specifc apps can plug into this event workflow
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    var configurationEndpointUrl = this.buildUrlFromContext(configInitializationURL, EndpointType.ORIGIN);
                    if (!configurationEndpointUrl) {
                        this.$log.error("[BlueskyHttpWrapper][Initialization] - Unable to build url from initialConfig url '" + configInitializationURL + "' with endpointType '" + EndpointType[EndpointType.ORIGIN] + "'. Aborting blueskyHttpService init.");
                        return;
                    }
                    this.getConfigPromise = this.$http.get(configurationEndpointUrl)
                        .then(
                    // success
                    function (clientConfigPromise) {
                        //TODO MGA: reject status not in 2XX ?
                        if (!clientConfigPromise.data) {
                            var msg = "Unable to retrieve http config data from '" + configInitializationURL + "'. Aborting blueskyHttpWrapperService initialization.";
                            _this.$log.error(msg);
                            //TODO MGA: toaster ?
                            return _this.$q.reject(msg);
                        }
                        _this.blueskyAjaxClientConfig = clientConfigPromise.data;
                        return clientConfigPromise.data;
                    }, 
                    // error
                    function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting blueskyHttpWrapperService initialization.');
                        return _this.$q.reject(error);
                    })
                        .then(
                    // success
                    function (blueskyClientConfig) {
                        //TODO MGA: handle case where client-side userRole was provided and not == srv-side user role ?
                        if (!blueskyClientConfig.currentUserRole) {
                            //If not provided by domain from which code was loaded, then try to fetch default userRole from CAPI endpoint
                            return _this.get('user-sso?profile=', { endpointType: EndpointType.CORE_API }).then(function (userSso) {
                                if (!userSso || !userSso.userRoleEntry) {
                                    var msg = 'Unable to retrieve CoreAPI default userSSO. Aborting httpWrapperService initialization.';
                                    _this.$log.error(msg);
                                    return _this.$q.reject(msg);
                                }
                                var userRoleToUse = selectedUserRole || userSso.userRoleEntry;
                                //TODO MGA: this needs to be put in shared extension method / service
                                _this.blueskyAjaxClientConfig.currentUserRole = userRoleToUse.name + " " + userRoleToUse.role + " " + userRoleToUse.silo;
                                _this.blueskyAjaxClientConfig.currentUser = userSso;
                                return blueskyClientConfig;
                            });
                        }
                        else {
                            //TODO MGA: we only load userSSO if no userRole was provided srv-side, should we load it in all cases ?
                            // already defined userRole sent from origin app, use it & set it as default.
                            return blueskyClientConfig;
                        }
                    });
                }
                //#endregion
                //#region public methods
                BlueskyHttpWrapper.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                BlueskyHttpWrapper.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                BlueskyHttpWrapper.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                BlueskyHttpWrapper.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                /**
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param file
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IBlueskyHttpRequestConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API ? (initCall)
                        return this.getConfigPromise.then(function () {
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            var requestConfig = _this.configureHttpCall(HttpMethod.POST, url, config);
                            if (requestConfig)
                                return _this.Upload.upload(requestConfig) //TODO MGA : not safe hard cast
                                    .then(_this.onSuccess(config), _this.onError(config), config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                    .finally(_this.finally);
                            return null; //TODO MGA: what to return ?
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // if no config returned, configuration failed, do not start ajax request
                        if (!angularHttpConfig) {
                            return _this.$q.reject('Unable to configure request correctly. Aborting getFile ajax call.');
                        }
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(config)(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 * @return null if not able to compute url. Otherwise, url of the request either partial or full based on endpointType.
                 */
                BlueskyHttpWrapper.prototype.buildUrlFromContext = function (urlInput, endpointType) {
                    if (!urlInput) {
                        this.$log.error('No URL input provided.');
                        return null;
                    }
                    // If Url starts with http:// or https:// => return as is, even if endpointType is not external.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        return urlInput;
                    }
                    // Else, we have a partial URL to complete: use provided endpoint type to determine how to complete url.
                    // Default value for endpointType if not provided is origin. TODO MGA: rule to discuss, here for retro-compatibility.
                    endpointType = endpointType || EndpointType.ORIGIN;
                    if (endpointType === EndpointType.EXTERNAL) {
                        this.$log.warn('Partial url provided for an external endpoint: the call will probably fail.');
                        // do not modify provided url if external (we cannot know how to complete it, even if partial).
                        return urlInput;
                    }
                    else {
                        //Compute url as combination of base url & url fragment given as input
                        var baseUrl = null;
                        if (endpointType === EndpointType.CORE_API) {
                            if (!this.blueskyAjaxClientConfig || !this.blueskyAjaxClientConfig.coreApiUrl) {
                                this.$log.error('Missing coreApiUrl in BlueskyAjaxClientConfig. cannot build valid url.');
                                return null;
                            }
                            baseUrl = this.blueskyAjaxClientConfig.coreApiUrl + CORE_API_ENDPOINT_SUFFIX;
                        }
                        else if (endpointType === EndpointType.MARKETING_API) {
                            if (!this.blueskyAjaxClientConfig || !this.blueskyAjaxClientConfig.marketingApiUrl) {
                                this.$log.error('Missing marketingApiUrl in BlueskyAjaxClientConfig. cannot build valid url.');
                                return null;
                            }
                            baseUrl = this.blueskyAjaxClientConfig.marketingApiUrl + MARKETING_API_ENDPOINT_SUFFIX;
                        }
                        else if (endpointType === EndpointType.QUOTE_WIZARD) {
                            if (!this.blueskyAjaxClientConfig || !this.blueskyAjaxClientConfig.quoteWizardUrl) {
                                this.$log.error('Missing quoteWizardUrl in BlueskyAjaxClientConfig. cannot build valid url.');
                                return null;
                            }
                            //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call will probably fail ...
                            baseUrl = this.blueskyAjaxClientConfig.quoteWizardUrl;
                        }
                        else if (endpointType === EndpointType.ORDER_ENTRY) {
                            if (!this.blueskyAjaxClientConfig || !this.blueskyAjaxClientConfig.orderEntryUrl) {
                                this.$log.error('Missing orderEntryUrl in BlueskyAjaxClientConfig. cannot build valid url.');
                                return null;
                            }
                            //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call will probably fail ...
                            baseUrl = this.blueskyAjaxClientConfig.orderEntryUrl;
                        }
                        else if (endpointType === EndpointType.ORDER_TRACKING) {
                            if (!this.blueskyAjaxClientConfig || !this.blueskyAjaxClientConfig.orderTrackingUrl) {
                                this.$log.error('Missing orderTrackingUrl in BlueskyAjaxClientConfig. cannot build valid url.');
                                return null;
                            }
                            //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call will probably fail ...
                            baseUrl = this.blueskyAjaxClientConfig.orderTrackingUrl;
                        } //TODO MGA: handle other endpoints !!! TI, MN, TG etc
                        else if (endpointType === EndpointType.ORIGIN) {
                            // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                            var controllerIsPresentRegex = /\w+\/\w+/;
                            var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                            baseUrl = this.getUrlPath(actionIsOnSameController);
                        }
                        else {
                            this.$log.error('Unsupported endpointType provided. Should not happen (expected default value Origin). Aborting.');
                            return null;
                        }
                        // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                        var urlFragmentStartsWithSlash = urlInput.slice(0, 1) === '/';
                        var baseUrlFragmentEndsWithSlash = baseUrl.slice(baseUrl.length - 1, baseUrl.length) === '/';
                        //based on starting/trailing slashes, return full url.
                        if (baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash)
                            // remove last '/' on baseUrl
                            return baseUrl.slice(0, baseUrl.length - 1) + urlInput;
                        else if (!baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash)
                            return baseUrl + '/' + urlInput;
                        else if ((baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash) ||
                            (!baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash))
                            return baseUrl + urlInput;
                    }
                    return null;
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure getConfig resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        if (angularHttpConfig)
                            return _this.$http(angularHttpConfig)
                                .then(_this.onSuccess(config), _this.onError(config))
                                .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                BlueskyHttpWrapper.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlMatches = baseUrlRegex.exec(url);
                    if (baseUrlMatches && baseUrlMatches.length && baseUrlMatches.length === 2) {
                        var baseUrlWithControllerName = baseUrlMatches[0];
                        var baseUrl = baseUrlMatches[1];
                        if (actionIsOnSameController) {
                            return baseUrlWithControllerName;
                        }
                        else {
                            return baseUrl;
                        }
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                BlueskyHttpWrapper.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                BlueskyHttpWrapper.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return BlueskyHttpWrapper;
            }());
            services.BlueskyHttpWrapper = BlueskyHttpWrapper;
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGVscy9ibHVlc2t5LWFqYXgtY2xpZW50LWNvbmZpZy5tb2RlbC50cyIsIm1vZGVscy9lbmRwb2ludC10eXBlLm1vZGVsLnRzIiwiYmx1ZXNreS1odHRwLXdyYXBwZXIucHJvdmlkZXIudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5zZXJ2aWNlLnRzIiwiYmx1ZXNreS1odHRwLXdyYXBwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK0JDOzs7O0FDL0JELElBQVU7QUFBVixDQUFBLFVBQVUsU0FBTztJQUFDLElBQUE7SUFBQSxDQUFBLFVBQUEsTUFBSTtRQUFDLElBQUE7UUFBQSxDQUFBLFVBQUEsUUFBTTtZQUFDLElBQUE7WUFBQSxDQUFBLFVBQUEsbUJBQWtCOztnQkFFNUMsQ0FBQSxVQUFZLGNBQVk7O29CQUVwQixhQUFBLGFBQUEsWUFBQSxLQUFBOztvQkFFQSxhQUFBLGFBQUEsY0FBQSxLQUFBOztvQkFFQSxhQUFBLGFBQUEsbUJBQUEsS0FBQTs7b0JBRUEsYUFBQSxhQUFBLGtCQUFBLEtBQUE7O29CQUVBLGFBQUEsYUFBQSxpQkFBQSxLQUFBOztvQkFFQSxhQUFBLGFBQUEsb0JBQUEsS0FBQTs7b0JBRUEsYUFBQSxhQUFBLGNBQUEsS0FBQTttQkFkUSxrQkFBQSxpQkFBQSxrQkFBQSxlQUFZO2dCQUF4QixJQUFZLGVBQUEsa0JBQUE7ZUFGYyxvQkFBQSxPQUFBLHNCQUFBLE9BQUEsb0JBQWlCO1dBQXhCLFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7OztBQ0FqQixJQUFVO0FBQVYsQ0FBQSxVQUFVLFNBQU87SUFBQyxJQUFBO0lBQUEsQ0FBQSxVQUFBLE1BQUk7UUFBQyxJQUFBO1FBQUEsQ0FBQSxVQUFBLFVBQVM7Ozs7Ozs7WUFTNUIsSUFBQSw4QkFBQSxZQUFBO2dCQUFBLFNBQUEsNkJBQUE7b0JBQUEsSUFBQSxRQUFBOztvQkFJWSxLQUFBLG1D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S0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFHWCxPQUFPLFlBQVk7Ozs7OztnQkFPZixtQkFBQSxVQUFBLDBDQUFSLFVBQWdELDBCQUFnQztvQkFDNUUsSUFBSSxDQUFDO3dCQUEwQixPQUFPO29CQUV0QyxJQUFJLFNBQVMseUJBQXlCLE1BQU0sS0FBSyxHQUFHLE9BQU8sTUFBTSxLQUFLO29CQUV0RSxPQUFPLE9BQU8sUUFBUSxNQUFNOztnQkFJcEMsT0FBQTs7WUFwbkJhLFNBQUEscUJBQWtCO1dBekNaLFdBQUEsS0FBQSxhQUFBLEtBQUEsV0FBUTtPQUFiLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBQzhsQmpCIiwiZmlsZSI6ImJsdWVza3ktaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQge1xyXG5cclxuICAgIGltcG9ydCBVc2VyU3NvRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVscy51c2VyTWFuYWdlbWVudC5Vc2VyU3NvRHRvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETyBNR0E6IHRob3NlIHBhcmFtZXRlcnMgYXJlIHNwZWNpZmljIHRvIG91ciBhdXRoICYgdXNlciByb2xlIHdvcmtmbG93IGluIEJTLiBBIHRlY2huaWNhbCBzZXJ2aWNlIHNob3VsZCBub3QgYmUgYXdhcmUgb2YgdGhlbSAoaW52ZXJzaW9uIG9mIHJlc3BvbnNhYmlsaXR5KTogY3JlYXRlIDIgc2VydmljZXMsIG9uZSBmb3IgdGVjaG5pY2FsIGJlaGF2aW9yIGFuZCBvbmUgZm9yIGZ1bmN0aW9uYWwgYmVoYXZpb3IgP1xyXG4gICAgICovXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHtcclxuXHJcbiAgICAgICAgLy8gY3JlZGVudGlhbHMgbWFuYWdlbWVudFxyXG4gICAgICAgIGNvcmVBcGlBdXRoVG9rZW46IHN0cmluZztcclxuICAgICAgICBjb3JlQXBpQXV0aFRva2VuVmFsaWRpdHlFbmREYXRlOiBEYXRlO1xyXG5cclxuICAgICAgICAvLyBjdXJyZW50VXNlciBhdXRoXHJcbiAgICAgICAgY3VycmVudFVzZXJSb2xlOiBzdHJpbmc7XHJcbiAgICAgICAgLy9UT0RPIE1HQTogb25seSB1c2VkIGJ5IHRoZSBodWIgQVRNLCBhbmQgbm90IHN0cm9uZ2x5IHR5cGVkIHRvIG90aGVyIGFwcHM6IHRvIGZhY3Rvcml6ZSBvciBjaGFuZ2UgP1xyXG4gICAgICAgIGN1cnJlbnRVc2VyPzogVXNlclNzb0R0bztcclxuXHJcbiAgICAgICAgLy8gYmFzZSB1cmwgb2YgQlMgQVBJcyAmIEFwcHMuXHJcbiAgICAgICAgY29yZUFwaVVybD86IHN0cmluZztcclxuICAgICAgICBtYXJrZXRpbmdBcGlVcmw/OiBzdHJpbmc7XHJcbiAgICAgICAgc2VsZkNhcmVBcGlVcmw/OiBzdHJpbmc7XHJcblxyXG4gICAgICAgIHF1b3RlV2l6YXJkVXJsPzogc3RyaW5nO1xyXG4gICAgICAgIG9yZGVyRW50cnlVcmw/OiBzdHJpbmc7XHJcbiAgICAgICAgb3JkZXJUcmFja2luZ1VybD86IHN0cmluZztcclxuICAgICAgICB0ZWNobmljYWxJbnZlbnRvcnlVcmw/OiBzdHJpbmc7XHJcbiAgICAgICAgbWV0cmFuZXRVcmw/OiBzdHJpbmc7XHJcbiAgICAgICAgdGVtcGxhdGVHZW5lcmF0b3JVcmw/OiBzdHJpbmc7XHJcbiAgICAgICAgc2FsZXNmb3JjZVVybD86IHN0cmluZztcclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBibHVlc2t5LmNvcmUubW9kZWxzLmJsdWVza3lIdHRwQ2xpZW50IHtcclxuICAgIC8vVE9ETyBNR0EgZG9jdW1lbnRcclxuICAgIGV4cG9ydCBlbnVtIEVuZHBvaW50VHlwZSB7XHJcbiAgICAgICAgLyoqIFVzZSBjdXJyZW50IGRvbWFpbiBmcm9tIHdoaWNoIHRoZSBhcHAgd2FzIGxvYWRlZC4gKi9cclxuICAgICAgICBPUklHSU4sXHJcbiAgICAgICAgLyoqIFVzZSBDb3JlQVBJIHVybC4gQnkgZGVmYXVsdCwgaGFuZGxlcyBhdXRoICYgdXNlclJvbGUuICovXHJcbiAgICAgICAgQ09SRV9BUEksXHJcbiAgICAgICAgLyoqIFVzZSBNYXJrZXRpbmdBUEkgdXJsLiBCeSBkZWZhdWx0LCBpZ25vcmVzIGF1dGggJiB1c2VyUm9sZS4gKi9cclxuICAgICAgICBNQVJLRVRJTkdfQVBJLFxyXG4gICAgICAgIC8qKiBVc2UgUXVvdGVXaXphcmQgdXJsIG9mIHRoZSBjdXJyZW50IGVudi4gQnkgZGVmYXVsdCwgaWdub3JlcyBhdXRoLCBzZXNzaW9uICYgdXNlclJvbGUuICovXHJcbiAgICAgICAgUVVPVEVfV0laQVJELFxyXG4gICAgICAgIC8qKiBVc2UgT3JkZXJFbnRyeSB1cmwgb2YgdGhlIGN1cnJlbnQgZW52LiBCeSBkZWZhdWx0LCBpZ25vcmVzIGF1dGgsIHNlc3Npb24gJiB1c2VyUm9sZS4gKi9cclxuICAgICAgICBPUkRFUl9FTlRSWSxcclxuICAgICAgICAvKiogVXNlIE9yZGVyVHJhY2tpbmcgdXJsIG9mIHRoZSBjdXJyZW50IGVudi4gQnkgZGVmYXVsdCwgaWdub3JlcyBhdXRoLCBzZXNzaW9uICYgdXNlclJvbGUuICovXHJcbiAgICAgICAgT1JERVJfVFJBQ0tJTkcsXHJcbiAgICAgICAgLyoqIEV4dGVybmFsIFVSTC4gQnkgZGVmYXVsdCwgZG8gbm90aGluZyAmIHBhc3MgaXQgdG8gJGh0dHAgc2VydmljZS4gKi9cclxuICAgICAgICBFWFRFUk5BTFxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5zZXJ2aWNlcyB7XHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuVXNlclJvbGVFbnRyeUR0bztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxyXG4gICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxyXG4gICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxyXG4gICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciBpbXBsZW1lbnRzIG5nLklTZXJ2aWNlUHJvdmlkZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw6IHN0cmluZyA9ICdDb3JlQXBpQXV0aC9HZXRDb3JlQXBpQ29uZmlnJzsgLy8gYnkgZGVmYXVsdDogVE9ETyBNR0EgY2hhbmdlIGl0IGluIGFsbCBPTSBhcHBzICEgbm90IGEgbWVhbmluZ2Z1bGwgbmFtZS5cclxuICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG8gPSBudWxsOyAvLyBieSBkZWZhdWx0IG5vdC1zZXQuXHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIGNvbmZpZ3VyYXRpb24gbWV0aG9kc1xyXG5cclxuICAgICAgICBwdWJsaWMgc2V0Q2xpZW50Q29uZmlnVVJMKGNsaWVudENvbmZpZ1VybFRvVXNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9IGNsaWVudENvbmZpZ1VybFRvVXNlIHx8IHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2V0VXNlclJvbGVUb1VzZSh1c2VyUm9sZTogVXNlclJvbGVFbnRyeUR0byk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSB1c2VyUm9sZSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGVyJ3MgZmFjdG9yeSBmdW5jdGlvblxyXG4gICAgICAgIC8qIEBuZ0luamVjdCAqL1xyXG4gICAgICAgIHB1YmxpYyAkZ2V0ID0gKCRodHRwOiBuZy5JSHR0cFNlcnZpY2UsXHJcbiAgICAgICAgICAgICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgJHE6IG5nLklRU2VydmljZSxcclxuICAgICAgICAgICAgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICB0b2FzdGVyOiBuZ3RvYXN0ZXIuSVRvYXN0ZXJTZXJ2aWNlKTogc2VydmljZXMuSUJsdWVza3lIdHRwV3JhcHBlciA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHNlcnZpY2VzLkJsdWVza3lIdHRwV3JhcHBlcigkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyLCB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsLCB0aGlzLnNlbGVjdGVkVXNlclJvbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhbmd1bGFyLm1vZHVsZSgnYmx1ZXNreS5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXHJcbiAgICAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2VzIHtcclxuXHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuVXNlclJvbGVFbnRyeUR0bztcclxuICAgIGltcG9ydCBVc2VyU3NvRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVscy51c2VyTWFuYWdlbWVudC5Vc2VyU3NvRHRvO1xyXG4gICAgaW1wb3J0IEJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gYmx1ZXNreS5jb3JlLm1vZGVscy5ibHVlc2t5SHR0cENsaWVudC5CbHVlc2t5QWpheENsaWVudENvbmZpZztcclxuICAgIGltcG9ydCBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcgPSBibHVlc2t5LmNvcmUubW9kZWxzLmJsdWVza3lIdHRwQ2xpZW50LklCbHVlc2t5SHR0cFJlcXVlc3RDb25maWc7XHJcbiAgICBpbXBvcnQgRmlsZUNvbnRlbnQgPSBibHVlc2t5LmNvcmUubW9kZWxzLmJsdWVza3lIdHRwQ2xpZW50LkZpbGVDb250ZW50O1xyXG4gICAgaW1wb3J0IEVuZHBvaW50VHlwZSA9IGJsdWVza3kuY29yZS5tb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQuRW5kcG9pbnRUeXBlO1xyXG5cclxuICAgIGVudW0gSHR0cE1ldGhvZCB7IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgfTtcclxuXHJcbiAgICAvL1RPRE8gTUdBOiBtYWtlIHRoaXMgaW5qZWN0YWJsZSAvLyBjb25maWd1cmFibGUgaW4gY29uZmlnIHBoYXNlXHJcbiAgICBjb25zdCBDT1JFX0FQSV9FTkRQT0lOVF9TVUZGSVggPSAnYXBpJztcclxuICAgIGNvbnN0IE1BUktFVElOR19BUElfRU5EUE9JTlRfU1VGRklYID0gJ2FwaSc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSBjb21tZW50XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUJsdWVza3lIdHRwV3JhcHBlciB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbCBzcnYtc2lkZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgaHR0cCBjbGllbnQsIHByb3ZpZGVkIGJ5IHRoZSBpbmplY3RlZCAnY29uZmlnSW5pdGlhbGl6YXRpb25VUkwnIGVuZHBvaW50LlxyXG4gICAgICAgICAqIFRoaXMgY29uZmlndXJhdGlvbiBkYXRhIGlzIGxvYWRlZCB1cG9uIGluaXRpYWxpemF0aW9uIG9mIHRoaXMgc2VydmljZSAodG8gYmUgdXNlZCBhcyBhIHNpbmdsZXRvbiBpbiB0aGUgYXBwKS4gQWxsIG90aGVyIHdlYiBjYWxscyBhcmUgYmxvY2tlZCBhcyBsb25nIGFzIHRoaXMgb25lIGlzIG5vdCBmaW5pc2hlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBibHVlc2t5QWpheENsaWVudENvbmZpZzogQmx1ZXNreUFqYXhDbGllbnRDb25maWc7XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+O1xyXG5cclxuICAgICAgICBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlciBpbXBsZW1lbnRzIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwcml2YXRlIGdldENvbmZpZ1Byb21pc2U6IG5nLklQcm9taXNlPGFueT47XHJcblxyXG4gICAgICAgIHB1YmxpYyBibHVlc2t5QWpheENsaWVudENvbmZpZzogQmx1ZXNreUFqYXhDbGllbnRDb25maWc7XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gY3RvclxyXG5cclxuICAgICAgICAvKiBAbmdJbmplY3QgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICAgICAgcHJpdmF0ZSAkaHR0cDogbmcuSUh0dHBTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRxOiBuZy5JUVNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgdG9hc3Rlcjogbmd0b2FzdGVyLklUb2FzdGVyU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBjb25maWdJbml0aWFsaXphdGlvblVSTDogc3RyaW5nLFxyXG4gICAgICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG9cclxuICAgICAgICApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBmZXRjaCB0aGUgY29uZmlndXJhdGlvbiBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBzZXJ2aWNlIHRvIHJ1biBmcm9tIHRoZSBwcm92aWRlZCBlbmRwb2ludFxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlLk9SSUdJTik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gYnVpbGQgdXJsIGZyb20gaW5pdGlhbENvbmZpZyB1cmwgJyR7Y29uZmlnSW5pdGlhbGl6YXRpb25VUkx9JyB3aXRoIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVbRW5kcG9pbnRUeXBlLk9SSUdJTl19Jy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBTZXJ2aWNlIGluaXQuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZSA9IHRoaXMuJGh0dHAuZ2V0PEJsdWVza3lBamF4Q2xpZW50Q29uZmlnPihjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpXHJcbiAgICAgICAgICAgICAgICAudGhlbjxCbHVlc2t5QWpheENsaWVudENvbmZpZz4oXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIChjbGllbnRDb25maWdQcm9taXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gYFVuYWJsZSB0byByZXRyaWV2ZSBodHRwIGNvbmZpZyBkYXRhIGZyb20gJyR7Y29uZmlnSW5pdGlhbGl6YXRpb25VUkx9Jy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi5gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0b2FzdGVyID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW48Qmx1ZXNreUFqYXhDbGllbnRDb25maWc+KFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICAoYmx1ZXNreUNsaWVudENvbmZpZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgY2FzZSB3aGVyZSBjbGllbnQtc2lkZSB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgYW5kIG5vdCA9PSBzcnYtc2lkZSB1c2VyIHJvbGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsdWVza3lDbGllbnRDb25maWcuY3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIG5vdCBwcm92aWRlZCBieSBkb21haW4gZnJvbSB3aGljaCBjb2RlIHdhcyBsb2FkZWQsIHRoZW4gdHJ5IHRvIGZldGNoIGRlZmF1bHQgdXNlclJvbGUgZnJvbSBDQVBJIGVuZHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQ8VXNlclNzb0R0bz4oJ3VzZXItc3NvP3Byb2ZpbGU9JywgeyBlbmRwb2ludFR5cGU6IEVuZHBvaW50VHlwZS5DT1JFX0FQSSB9KS50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlnPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlclNzbykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJTc28gfHwgIXVzZXJTc28udXNlclJvbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmFibGUgdG8gcmV0cmlldmUgQ29yZUFQSSBkZWZhdWx0IHVzZXJTU08uIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJSb2xlVG9Vc2UgPSBzZWxlY3RlZFVzZXJSb2xlIHx8IHVzZXJTc28udXNlclJvbGVFbnRyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRoaXMgbmVlZHMgdG8gYmUgcHV0IGluIHNoYXJlZCBleHRlbnNpb24gbWV0aG9kIC8gc2VydmljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UubmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5yb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLnNpbG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyID0gdXNlclNzbztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHVlc2t5Q2xpZW50Q29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHdlIG9ubHkgbG9hZCB1c2VyU1NPIGlmIG5vIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBzcnYtc2lkZSwgc2hvdWxkIHdlIGxvYWQgaXQgaW4gYWxsIGNhc2VzID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRlZmluZWQgdXNlclJvbGUgc2VudCBmcm9tIG9yaWdpbiBhcHAsIHVzZSBpdCAmIHNldCBpdCBhcyBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcclxuXHJcbiAgICAgICAgZ2V0PFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3N0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xyXG4gICAgICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAgICAgKiBAcGFyYW0gZmlsZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVwbG9hZEluQmFzZTY0SnNvbikge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHRoaXMgZGVsYXlzIG5leHQgY2FsbCBhbmQgdXBsb2FkIGlzIG5vdCBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgaXMgZmluaXNoZWQsIGV2ZW4gaWYgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkID8/P1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLmJhc2U2NERhdGFVcmwoZmlsZSkudGhlbigoZmlsZUJhc2U2NFVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQtY29kZWQga2V5IHRvIGZldGNoIGJhc2U2NCBlbmNvZGluZywgdG8gcGFyYW1ldHJpemUgd2l0aCBzZXJ2ZXItc2lkZSAhXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUJhc2U2NFVybCA9IGZpbGVCYXNlNjRVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWwgcG9zdCBpbiBjYXNlIG9mIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgPyAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Q29uZmlnKSAvLyBpZiBubyBjb25maWcgcmV0dXJuZWQsIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBkbyBub3Qgc3RhcnQgYWpheCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC51cGxvYWQ8VD4oPG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklGaWxlVXBsb2FkQ29uZmlnRmlsZT5yZXF1ZXN0Q29uZmlnKSAvL1RPRE8gTUdBIDogbm90IHNhZmUgaGFyZCBjYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzczxUPihjb25maWcpLCB0aGlzLm9uRXJyb3I8VD4oY29uZmlnKSwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vVE9ETyBNR0E6IHdoYXQgdG8gcmV0dXJuID9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRvd25sb2FkIGEgZmlsZSBpbiB0aGUgZm9ybSBvZiBhIGJ5dGUtc3RyZWFtIGZyb20gYW4gZW5kcG9pbnQgYW5kIHdyYXAgaXQgaW50byBhIEZpbGVDb250ZW50IG9iamVjdCB3aXRoIG5hbWUsIHR5cGUgJiBzaXplIHByb3BlcnRpZXMgcmVhZCBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIHNlcnZldXIuXHJcbiAgICAgICAgICogSXQgaXMgdGhlIHJlc3BvbnNhYmlsaXR5IG9mIHRoZSBjb25zdW1lciB0byBkbyBzb21ldGhpbmcgd2l0aCB0aGUgd3JhcHBlZCBieXRlQXJyYXkgKGZvciBleGFtcGxlIGRvd25sb2FkIHRoZSBmaWxlLCBvciBzaG93IGl0IGluc2lkZSB0aGUgd2ViUGFnZSBldGMpLlxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xyXG4gICAgICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWROYW1lXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkU2l6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGVcclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFySHR0cENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdCgnVW5hYmxlIHRvIGNvbmZpZ3VyZSByZXF1ZXN0IGNvcnJlY3RseS4gQWJvcnRpbmcgZ2V0RmlsZSBhamF4IGNhbGwuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxyXG4gICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHJcbiAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8QXJyYXlCdWZmZXI+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuPEZpbGVDb250ZW50PigoaHR0cFJlc3BvbnNlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLm9uU3VjY2VzczxBcnJheUJ1ZmZlcj4oY29uZmlnKShodHRwUmVzcG9uc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcHJvbWlzZSByZWplY3Rpb24gdnMuIHJldHVybiBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcikgcmV0dXJuIG51bGw7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlYWQgZmlsZSBpbmZvIGZyb20gcmVzcG9uc2UtaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQ6IEZpbGVDb250ZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE51bWJlcihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1sZW5ndGgnKSkgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LXR5cGUnKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub25FcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxyXG4gICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKSBcclxuICAgICAgICAgKiBPdGhlcndpc2UsIHRyaWVzIHRvIGZpbmQgdGhlIGJhc2UgVVJMIG9mIHRoZSBjdXJyZW50IEJsdWVTa3kgYXBwIHdpdGggb3Igd2l0aG91dCB0aGUgaW5jbHVkZWQgQ29udHJvbGxlciBhbmQgcmV0dXJucyB0aGUgZnVsbCBVcmwgXHJcbiAgICAgICAgICogQHBhcmFtIHVybElucHV0IDogVE9ETyBNR0E6IGRvY3VtZW50IGRpZmZlcmVudCBraW5kIG9mIHVybHMgdGhhdCB0aGlzIG1ldGhvZCBjYW4gdGFrZSBhcyBpbnB1dCAoZnVsbCwgcGFydGlhbCBldGMpXHJcbiAgICAgICAgICogQHJldHVybiBudWxsIGlmIG5vdCBhYmxlIHRvIGNvbXB1dGUgdXJsLiBPdGhlcndpc2UsIHVybCBvZiB0aGUgcmVxdWVzdCBlaXRoZXIgcGFydGlhbCBvciBmdWxsIGJhc2VkIG9uIGVuZHBvaW50VHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nLCBlbmRwb2ludFR5cGU/OiBFbmRwb2ludFR5cGUpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF1cmxJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdObyBVUkwgaW5wdXQgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgVXJsIHN0YXJ0cyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gPT4gcmV0dXJuIGFzIGlzLCBldmVuIGlmIGVuZHBvaW50VHlwZSBpcyBub3QgZXh0ZXJuYWwuXHJcbiAgICAgICAgICAgIGlmICh1cmxJbnB1dC5zbGljZSgwLCAnaHR0cDovLycubGVuZ3RoKSA9PT0gJ2h0dHA6Ly8nIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJbnB1dC5zbGljZSgwLCAnaHR0cHM6Ly8nLmxlbmd0aCkgPT09ICdodHRwczovLycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRWxzZSwgd2UgaGF2ZSBhIHBhcnRpYWwgVVJMIHRvIGNvbXBsZXRlOiB1c2UgcHJvdmlkZWQgZW5kcG9pbnQgdHlwZSB0byBkZXRlcm1pbmUgaG93IHRvIGNvbXBsZXRlIHVybC5cclxuXHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIGVuZHBvaW50VHlwZSBpZiBub3QgcHJvdmlkZWQgaXMgb3JpZ2luLiBUT0RPIE1HQTogcnVsZSB0byBkaXNjdXNzLCBoZXJlIGZvciByZXRyby1jb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICBlbmRwb2ludFR5cGUgPSBlbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlLk9SSUdJTjtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5FWFRFUk5BTCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1BhcnRpYWwgdXJsIHByb3ZpZGVkIGZvciBhbiBleHRlcm5hbCBlbmRwb2ludDogdGhlIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IG1vZGlmeSBwcm92aWRlZCB1cmwgaWYgZXh0ZXJuYWwgKHdlIGNhbm5vdCBrbm93IGhvdyB0byBjb21wbGV0ZSBpdCwgZXZlbiBpZiBwYXJ0aWFsKS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vQ29tcHV0ZSB1cmwgYXMgY29tYmluYXRpb24gb2YgYmFzZSB1cmwgJiB1cmwgZnJhZ21lbnQgZ2l2ZW4gYXMgaW5wdXRcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVVybDogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuQ09SRV9BUEkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmNvcmVBcGlVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIGNvcmVBcGlVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY29yZUFwaVVybCArIENPUkVfQVBJX0VORFBPSU5UX1NVRkZJWDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLk1BUktFVElOR19BUEkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm1hcmtldGluZ0FwaVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ01pc3NpbmcgbWFya2V0aW5nQXBpVXJsIGluIEJsdWVza3lBamF4Q2xpZW50Q29uZmlnLiBjYW5ub3QgYnVpbGQgdmFsaWQgdXJsLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm1hcmtldGluZ0FwaVVybCArIE1BUktFVElOR19BUElfRU5EUE9JTlRfU1VGRklYO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuUVVPVEVfV0laQVJEKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyB8fCAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5xdW90ZVdpemFyZFVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ01pc3NpbmcgcXVvdGVXaXphcmRVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGhhbmRsZSBPTSBhcHBzIGV4dGVybmFsIGNhbGxzIHdpdGhvdXQgc2Vzc2lvbiBwcm92aWRlZCA/IHdpbGwgcmVzdWx0IGluIGEgcmVkaXJlY3QgYW5kIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLnF1b3RlV2l6YXJkVXJsO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuT1JERVJfRU5UUlkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm9yZGVyRW50cnlVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIG9yZGVyRW50cnlVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGhhbmRsZSBPTSBhcHBzIGV4dGVybmFsIGNhbGxzIHdpdGhvdXQgc2Vzc2lvbiBwcm92aWRlZCA/IHdpbGwgcmVzdWx0IGluIGEgcmVkaXJlY3QgYW5kIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm9yZGVyRW50cnlVcmw7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5PUkRFUl9UUkFDS0lORykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHwgIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcub3JkZXJUcmFja2luZ1VybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ01pc3Npbmcgb3JkZXJUcmFja2luZ1VybCBpbiBCbHVlc2t5QWpheENsaWVudENvbmZpZy4gY2Fubm90IGJ1aWxkIHZhbGlkIHVybC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaGFuZGxlIE9NIGFwcHMgZXh0ZXJuYWwgY2FsbHMgd2l0aG91dCBzZXNzaW9uIHByb3ZpZGVkID8gd2lsbCByZXN1bHQgaW4gYSByZWRpcmVjdCBhbmQgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcub3JkZXJUcmFja2luZ1VybDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IC8vVE9ETyBNR0E6IGhhbmRsZSBvdGhlciBlbmRwb2ludHMgISEhIFRJLCBNTiwgVEcgZXRjXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5PUklHSU4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleCA9IC9cXHcrXFwvXFx3Ky87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5nZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1Vuc3VwcG9ydGVkIGVuZHBvaW50VHlwZSBwcm92aWRlZC4gU2hvdWxkIG5vdCBoYXBwZW4gKGV4cGVjdGVkIGRlZmF1bHQgdmFsdWUgT3JpZ2luKS4gQWJvcnRpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbGVhbiB1c2VkIHRvIHRyeSB0byBkZXRlcm1pbmUgY29ycmVjdCBmdWxsIHVybCAoYWRkIC8gb3Igbm90IGJlZm9yZSB0aGUgdXJsIGZyYWdtZW50IGRlcGVuZGluZyBvbiBpZiBmb3VuZCBvciBub3QpXHJcbiAgICAgICAgICAgICAgICB2YXIgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPSB1cmxJbnB1dC5zbGljZSgwLCAxKSA9PT0gJy8nO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggPSBiYXNlVXJsLnNsaWNlKGJhc2VVcmwubGVuZ3RoIC0gMSwgYmFzZVVybC5sZW5ndGgpID09PSAnLyc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9iYXNlZCBvbiBzdGFydGluZy90cmFpbGluZyBzbGFzaGVzLCByZXR1cm4gZnVsbCB1cmwuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsLnNsaWNlKDAsIGJhc2VVcmwubGVuZ3RoIC0gMSkgKyB1cmxJbnB1dDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgIXVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cclxuICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgYWpheDxUPihtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKG1ldGhvZCwgdXJsLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFySHR0cENvbmZpZykgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwPFQ+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzczxUPihjb25maWcpLCB0aGlzLm9uRXJyb3I8VD4oY29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFByZXBhcmVzIGEge0BsaW5rIG5nIyRodHRwI2NvbmZpZyBjb25maWd9IG9iamVjdCBmb3IgJGh0dHAgY2FsbC5cclxuICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxyXG4gICAgICAgICogIC0gQWpheCBjYWxsc1xyXG4gICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxyXG4gICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS4gICBcclxuICAgICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgICAgKiBAcmV0dXJucyB7bmcuJGh0dHAuY29uZmlnfSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcmVhZHkgdG8gYmUgaW5qZWN0ZWQgaW50byBhICRodHRwIGNhbGwuIFxyXG4gICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBjb25maWd1cmVIdHRwQ2FsbCA9IChtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUmVxdWVzdENvbmZpZyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSBmb3IgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlLk9SSUdJTjsgLy8gZGVmYXVsdCB2YWx1ZTogaWYgbm90IHNwZWNpZmllZCwgZW5kcG9pbnQgdG8gdXNlIGlzIHN1cHBvc2VkIHRvIGJlIHRoZSBvcmlnaW4uIFxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjYXN0IGlzIG5vdCBzYWZlLCB3ZSBtYXkgZm9yZ2V0IHRvIHNldCB1cmwgJiBtZXRob2QgcGFyYW1ldGVycy4gVE9GSVguXHJcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2V0IGFsbCBub24tZmlsdGVyZWQgcGFyYW1ldGVycyAmIGtlZXAgdGhlbSBmb3IgdGhpcyBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICB2YXIgY29uZmlnRnVsbCA9IDxuZy5JUmVxdWVzdENvbmZpZz5jb25maWc7XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzdXBwb3J0IG1hcHBpbmcgYmV0d2VlbiB1cGxvYWQgJiBwb3N0IGhlcmUgP1xyXG4gICAgICAgICAgICBjb25maWdGdWxsLm1ldGhvZCA9IEh0dHBNZXRob2RbbWV0aG9kXTtcclxuXHJcbiAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gY29uZmlndXJlIGRlZmF1bHQgY29uZmlnIGZsYWdzIGJhc2VkIG9uIHRhcmdldCBlbmRwb2ludFxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLkNPUkVfQVBJKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGxpY2l0bHkgd3JvbmcgaW5wdXQgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9PT0gZmFsc2UgfHxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ29yZUFwaUp3dEF1dGhUb2tlbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBDb3JlQVBJIGNhbGwgaW50ZW5kZWQgd2l0aCBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBBYm9ydGluZyBhamF4IGNhbGwuYCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25maWcgdmFsdWVzIGZvciBDb3JlQVBJIGVuZHBvaW50IGFyZSBkaWZmZXJlbnQgZnJvbSBkZWZhdWx0LCBzbyB3ZSBtdXN0IHNwZWNpZnkgdGhlbS5cclxuICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDb3JlQXBpSnd0QXV0aFRva2VuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5NQVJLRVRJTkdfQVBJIHx8XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuT1JJR0lOIHx8XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuUVVPVEVfV0laQVJEIHx8XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuT1JERVJfRU5UUlkgfHxcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5PUkRFUl9UUkFDS0lORykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IHByb3ZpZGUgbW9yZSBjb21wbGV0ZSBmZWVkYmFja3Mgb24gdGhvc2Ugc3BlY2lmaWMgZW5kcG9pbnRzID9cclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUNvcmVBcGlKd3RBdXRoVG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1tCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVzZXJSb2xlICYgSnd0VG9rZW4gc2hvdWxkIG5vdCBiZSBwcm92aWRlZCBmb3IgdGFyZ2V0IGVuZHBvaW50LiAnKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLkVYVEVSTkFMKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gdHJ1ZTsgLy8gZG8gbm90IGFkZCBYbWxIdHRwUmVxdWVzdCBpZiBleHRlcm5hbCBVcmwgYnkgZGVmYXVsdDogbWlnaHQgY3JlYXRlIGNvbmZsaWN0cyBvbiBjZXJ0YWluIHNlcnZlcnMuIFRPRE8gTUdBIHRvIGNvbmZpcm1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdWyR7Y29uZmlnRnVsbC5tZXRob2R9IC8gJHt1cmx9XSAtIFVuc3VwcG9ydGVkIGVuZHBvaW50VHlwZSBwcm92aWRlZDogJyR7RW5kcG9pbnRUeXBlW2NvbmZpZy5lbmRwb2ludFR5cGVdfScuIEFib3J0aW5nLmApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXHJcbiAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cclxuICAgICAgICAgICAgY29uZmlnLnVzZUNvcmVBcGlKd3RBdXRoVG9rZW4gPSBjb25maWcudXNlQ29yZUFwaUp3dEF1dGhUb2tlbiB8fCBmYWxzZTsgLy8gZGVmYXVsdCB2YWx1ZTogZG9uJ3QgdHJhbnNtaXQgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHJlbW90ZSBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQuXHJcbiAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgPSBjb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zIHx8IGZhbHNlOyAvL3NldCBkZWZhdWx0IHZhbHVlIGZvciBkaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgdG8gZmFsc2UgYXMgaXQncyBwYXJ0IG9mIHRoZSBub3JtYWwgYmVoYXZpb3IgZXhwZWN0ZWQgZm9yIHRoaXMgc2VydmljZS5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gYnVpbGQgYSB2YWxpZCB1cmwgZnJvbSBpbnB1dCAmIGVuZHBvaW50VHlwZS5cclxuICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQodXJsLCBjb25maWcuZW5kcG9pbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnRnVsbC51cmwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIC0gVW5hYmxlIHRvIGJ1aWxkIHVybCBmcm9tIHVybElucHV0ICcke3VybH0nIHdpdGggZW5kcG9pbnRUeXBlICcke0VuZHBvaW50VHlwZVtjb25maWcuZW5kcG9pbnRUeXBlXX0nLiBBYm9ydGluZyBhamF4IGNhbGwuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGNhbGwgd2hlbiBtaXNzaW5nIG1hbmRhdG9yeSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3NhcnkgdXNlclJvbGUgaW4gYmx1ZXNreUFqYXhDbGllbnRDb25maWcuIEFib3J0aW5nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VDb3JlQXBpSnd0QXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHwgIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY29yZUFwaUF1dGhUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3Nhcnkgand0VG9rZW4gaW4gYmx1ZXNreUFqYXhDbGllbnRDb25maWcuIEFib3J0aW5nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY29yZUFwaUF1dGhUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Ugc3BlY2lmaWMgY29kZSwgdG8gcmVtb3ZlLCBvciBhdCBsZWFzdCBwdXQgaW4gYXMgY29uZmlnIHBhcmFtXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnRnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlci5cclxuICAgICAgICAgKiBDYXB0dXJlcyB0aGUgaW5wdXQgcGFyYW1ldGVycyBhdCB0aGUgbW9tZW50IG9mIGl0cyBkZWNsYXJhdGlvbiAmIHJldHVybiB0aGUgcmVhbCBoYW5kbGVyIHRvIGJlIGNhbGxlZCB1cG9uIHByb21pc2UgY29tcGxldGlvbi5cclxuICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAqICAtIGNhbGxpbmdDb25maWc6IGNvbmZpZ3VyYXRpb24gdXNlZCB0byBtYWtlIHRoZSBhamF4IGNhbGwsIGluIGNhc2UgdGhlIHJldHVybmVkIHByb21pc2UgaXMgbnVsbC9lbXB0eSBhbmQgZG9lc24ndCBjb250YWluIG5lY2Vzc2FyeSBkYXRhIGZvciBkZWJ1Z2dpbmcuXHJcbiAgICAgICAgICogIC0gZ2V0Q29tcGxldGVSZXNwb25zZU9iamVjdDogZmxhZyBpbmRpY2F0aW9uIGlmIHdlIG11c3QgcmV0dXJuIHRoZSBmdWxsIHJlc3BvbnNlIG9iamVjdCBhbG9uZyB3aXRoIGhlYWRlcnMgYW5kIHN0YXR1cyBvciBvbmx5IHRoZSBpbm5lciBkYXRhLiBCeSBkZWZhdWx0ICYgaWYgbm90IHNwZWNpZmllZCwgb25seSByZXR1cm5zIGlubmVyIGRhdGEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBvblN1Y2Nlc3MgPSA8VD4ob3JpZ2luYWxDb25maWc6IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pID0+IFQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gPFQ+KGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxUPik6IFQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtdWx0aS10eXBlIHJldHVybiBpbiBjYXNlIG9mIHJlamVjdGlvbiBvciBkbyBzb21ldGhpbmcgZWxzZSA/IHRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSB1c2VkIHN5bmNocm9ub3VzbHkgd2l0aG91dCBwcm9taXNlIHdhaXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpOyAvLyBSZWplY3QgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBpZiBzdGF0dXMgIT0gMlhYID9cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgd2hlbiBBUEkgaXMgZml4ZWQuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExNzQ2ODk0L3doYXQtaXMtdGhlLXByb3Blci1yZXN0LXJlc3BvbnNlLWNvZGUtZm9yLWEtdmFsaWQtcmVxdWVzdC1idXQtYW4tZW1wdHktZGF0YVxyXG4gICAgICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcclxuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdVbmV4cGVjdGVkIHJlc3BvbnNlJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNhbWUgYmVoYXZpb3IgYWxzbyBvbiBhIEdFVCByZXF1ZXN0ID8gaWYgcmVxdWVzdCBpcyBHRVQgYW5kIHJlc3BvbnNlIGlzIDIwMCB3aXRoIG5vIGRhdGEsIHJldHVybiBlcnJvciA/IChwYXNzIGluIHBhcmFtZXRlciByZXF1ZXN0IGNvbnRleHQgdG8gbG9nIHRoaXMgZXJyb3IpLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZGVidWcoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gb25seSB0aGUgZGF0YSBleHBlY3RlZCBmb3IgY2FsbGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFByb21pc2UuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgICogVE9ETyBNR0E6IGFuZ3VsYXIgc2lnbmF0dXJlcyBpbmRpY2F0ZXMgdGhhdCBwYXJhbWV0ZXIgaXMgcmVqZWN0aW9uIHJlYXNvbiwgbm90IG5lY2Vzc2FyaWx5IGh0dHBQcm9taXNlOiBpbnZlc3RpZ2F0ZSAmIGZpeCBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2UgXHJcbiAgICAgICAgICogQHJldHVybnMge30gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBvbkVycm9yID0gPFQ+KG9yaWdpbmFsQ29uZmlnOiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiAoaHR0cFByb21pc2U6IG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4pID0+IGFueSA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gPFQ+KGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxhbnk+KTogYW55ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHN1cHBvc2UgaW4gY2FzZSBvZiBubyByZXNwb25zZSB0aGF0IHRoZSBzcnYgZGlkbid0IHNlbmQgYW55IHJlc3BvbnNlLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXHJcbiAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlIHx8ICFodHRwUHJvbWlzZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YSA9ICdTZXJ2ZXIgbm90IHJlc3BvbmRpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUHJvbWlzZS5oZWFkZXJzKCdDb250ZW50LVR5cGUnKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgY29udGVudFR5cGUgdG8gdHJ5IHRvIGRpc3BsYXkgZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTogc3RyaW5nID0gXCJcIjsgLy9kZWZhdWx0IG1lc3NhZ2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChyZXNwb25zZS5kYXRhLk1vZGVsU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLy9UT0RPIE1HQSA6IGhhbmRsZSB0aGlzIHdoZW4gd2VsbCBmb3JtYXR0ZWQgc2VydmVyLXNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSAmJiBhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdTZXJ2ZXIgcmVzcG9uc2UgZXJyb3InLCBtZXNzYWdlICsgJ1xcbiBTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbSFRUUCAke2h0dHBQcm9taXNlLmNvbmZpZy5tZXRob2R9XSBbJHtodHRwUHJvbWlzZS5jb25maWcudXJsfV1gLCBodHRwUHJvbWlzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYWpheCBjYWxsLCByZWdhcmRsZXNzIG9mIGl0J3Mgc3VjY2VzcyBvciBmYWlsdXJlLlxyXG4gICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxyXG4gICAgICAgICAqIFRPRE8gTUdBIGludmVyc2lvbiBvZiByZXNwb25zYWJpbGl0eTogbWFrZSB0aGlzIGV4dGVuc2libGUgc28gdGhhdCBzcGVjaWZjIGFwcHMgY2FuIHBsdWcgaW50byB0aGlzIGV2ZW50IHdvcmtmbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBmaW5hbGx5ID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBNR0EgOiB1c2luZyBtZXRob2QgZnJvbSBMYXlvdXQuanMgOiB0byBkb2N1bWVudCB0byBub3QgaGFuZGxlIGR1cGxpY2F0ZSBjb2RlICEhXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcjogYm9vbGVhbik6IHN0cmluZyB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFJlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ky87XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLiR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsTWF0Y2hlcyA9IGJhc2VVcmxSZWdleC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybE1hdGNoZXMgJiYgYmFzZVVybE1hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybE1hdGNoZXNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVVybCA9IGJhc2VVcmxNYXRjaGVzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcclxuICAgICAgICBwcml2YXRlIGdldEN1cnJlbnRTZXNzaW9uSUQoKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcclxuICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcbiAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVwZGF0ZSByZWdleHAgdG8gdGhlIG9uZSBiZWxvd1xyXG4gICAgICAgICAgICAvL3ZhciBiYXNlVXJsUmVnZXggPSAvKGh0dHBzOlxcL1xcL1tcXHcuLV0rXFwvW1xcdy4tXStcXC9cXChTXFwoXFx3K1xcKVxcKVxcLylcXHcrLztcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2V4cEFycmF5ID0gc2Vzc2lvblJlZ2V4LmV4ZWMocGF0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVG9vIG1hbnkgbWF0Y2hlcyBmb3VuZCBmb3IgdGhlIHNlc3Npb25JRCBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgdXJsLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmltIHRoZSBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciB0byByZXR1cm4gb25seSB0aGUgZmlsZW5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgaWYgKCFjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIlxuXG5cblxudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIG1vZGVscztcbiAgICAgICAgKGZ1bmN0aW9uIChtb2RlbHMpIHtcbiAgICAgICAgICAgIHZhciBibHVlc2t5SHR0cENsaWVudDtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYmx1ZXNreUh0dHBDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChFbmRwb2ludFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIFVzZSBjdXJyZW50IGRvbWFpbiBmcm9tIHdoaWNoIHRoZSBhcHAgd2FzIGxvYWRlZC4gKi9cbiAgICAgICAgICAgICAgICAgICAgRW5kcG9pbnRUeXBlW0VuZHBvaW50VHlwZVtcIk9SSUdJTlwiXSA9IDBdID0gXCJPUklHSU5cIjtcbiAgICAgICAgICAgICAgICAgICAgLyoqIFVzZSBDb3JlQVBJIHVybC4gQnkgZGVmYXVsdCwgaGFuZGxlcyBhdXRoICYgdXNlclJvbGUuICovXG4gICAgICAgICAgICAgICAgICAgIEVuZHBvaW50VHlwZVtFbmRwb2ludFR5cGVbXCJDT1JFX0FQSVwiXSA9IDFdID0gXCJDT1JFX0FQSVwiO1xuICAgICAgICAgICAgICAgICAgICAvKiogVXNlIE1hcmtldGluZ0FQSSB1cmwuIEJ5IGRlZmF1bHQsIGlnbm9yZXMgYXV0aCAmIHVzZXJSb2xlLiAqL1xuICAgICAgICAgICAgICAgICAgICBFbmRwb2ludFR5cGVbRW5kcG9pbnRUeXBlW1wiTUFSS0VUSU5HX0FQSVwiXSA9IDJdID0gXCJNQVJLRVRJTkdfQVBJXCI7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBVc2UgUXVvdGVXaXphcmQgdXJsIG9mIHRoZSBjdXJyZW50IGVudi4gQnkgZGVmYXVsdCwgaWdub3JlcyBhdXRoLCBzZXNzaW9uICYgdXNlclJvbGUuICovXG4gICAgICAgICAgICAgICAgICAgIEVuZHBvaW50VHlwZVtFbmRwb2ludFR5cGVbXCJRVU9URV9XSVpBUkRcIl0gPSAzXSA9IFwiUVVPVEVfV0laQVJEXCI7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBVc2UgT3JkZXJFbnRyeSB1cmwgb2YgdGhlIGN1cnJlbnQgZW52LiBCeSBkZWZhdWx0LCBpZ25vcmVzIGF1dGgsIHNlc3Npb24gJiB1c2VyUm9sZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgRW5kcG9pbnRUeXBlW0VuZHBvaW50VHlwZVtcIk9SREVSX0VOVFJZXCJdID0gNF0gPSBcIk9SREVSX0VOVFJZXCI7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBVc2UgT3JkZXJUcmFja2luZyB1cmwgb2YgdGhlIGN1cnJlbnQgZW52LiBCeSBkZWZhdWx0LCBpZ25vcmVzIGF1dGgsIHNlc3Npb24gJiB1c2VyUm9sZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgRW5kcG9pbnRUeXBlW0VuZHBvaW50VHlwZVtcIk9SREVSX1RSQUNLSU5HXCJdID0gNV0gPSBcIk9SREVSX1RSQUNLSU5HXCI7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBFeHRlcm5hbCBVUkwuIEJ5IGRlZmF1bHQsIGRvIG5vdGhpbmcgJiBwYXNzIGl0IHRvICRodHRwIHNlcnZpY2UuICovXG4gICAgICAgICAgICAgICAgICAgIEVuZHBvaW50VHlwZVtFbmRwb2ludFR5cGVbXCJFWFRFUk5BTFwiXSA9IDZdID0gXCJFWFRFUk5BTFwiO1xuICAgICAgICAgICAgICAgIH0pKGJsdWVza3lIdHRwQ2xpZW50LkVuZHBvaW50VHlwZSB8fCAoYmx1ZXNreUh0dHBDbGllbnQuRW5kcG9pbnRUeXBlID0ge30pKTtcbiAgICAgICAgICAgICAgICB2YXIgRW5kcG9pbnRUeXBlID0gYmx1ZXNreUh0dHBDbGllbnQuRW5kcG9pbnRUeXBlO1xuICAgICAgICAgICAgfSkoYmx1ZXNreUh0dHBDbGllbnQgPSBtb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQgfHwgKG1vZGVscy5ibHVlc2t5SHR0cENsaWVudCA9IHt9KSk7XG4gICAgICAgIH0pKG1vZGVscyA9IGNvcmUubW9kZWxzIHx8IChjb3JlLm1vZGVscyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG5cblxudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIHNlcnZpY2VzO1xuICAgICAgICAoZnVuY3Rpb24gKHNlcnZpY2VzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxuICAgICAgICAgICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxuICAgICAgICAgICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxuICAgICAgICAgICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9ICdDb3JlQXBpQXV0aC9HZXRDb3JlQXBpQ29uZmlnJzsgLy8gYnkgZGVmYXVsdDogVE9ETyBNR0EgY2hhbmdlIGl0IGluIGFsbCBPTSBhcHBzICEgbm90IGEgbWVhbmluZ2Z1bGwgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gbnVsbDsgLy8gYnkgZGVmYXVsdCBub3Qtc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZXIncyBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8qIEBuZ0luamVjdCAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRnZXQgPSBmdW5jdGlvbiAoJGh0dHAsICR3aW5kb3csICRsb2csICRxLCAkbG9jYXRpb24sIFVwbG9hZCwgdG9hc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzZXJ2aWNlcy5CbHVlc2t5SHR0cFdyYXBwZXIoJGh0dHAsICR3aW5kb3csICRsb2csICRxLCAkbG9jYXRpb24sIFVwbG9hZCwgdG9hc3RlciwgX3RoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwsIF90aGlzLnNlbGVjdGVkVXNlclJvbGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHVibGljIGNvbmZpZ3VyYXRpb24gbWV0aG9kc1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyLnByb3RvdHlwZS5zZXRDbGllbnRDb25maWdVUkwgPSBmdW5jdGlvbiAoY2xpZW50Q29uZmlnVXJsVG9Vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9IGNsaWVudENvbmZpZ1VybFRvVXNlIHx8IHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlci5wcm90b3R5cGUuc2V0VXNlclJvbGVUb1VzZSA9IGZ1bmN0aW9uICh1c2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSB1c2VyUm9sZSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHNlcnZpY2VzLkJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyID0gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXI7XG4gICAgICAgICAgICBhbmd1bGFyLm1vZHVsZSgnYmx1ZXNreS5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXG4gICAgICAgICAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XG4gICAgICAgIH0pKHNlcnZpY2VzID0gY29yZS5zZXJ2aWNlcyB8fCAoY29yZS5zZXJ2aWNlcyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZXM7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZXMpIHtcbiAgICAgICAgICAgIHZhciBFbmRwb2ludFR5cGUgPSBibHVlc2t5LmNvcmUubW9kZWxzLmJsdWVza3lIdHRwQ2xpZW50LkVuZHBvaW50VHlwZTtcbiAgICAgICAgICAgIHZhciBIdHRwTWV0aG9kO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChIdHRwTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiR0VUXCJdID0gMF0gPSBcIkdFVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBPU1RcIl0gPSAxXSA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBVVFwiXSA9IDJdID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJERUxFVEVcIl0gPSAzXSA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICB9KShIdHRwTWV0aG9kIHx8IChIdHRwTWV0aG9kID0ge30pKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2UgdGhpcyBpbmplY3RhYmxlIC8vIGNvbmZpZ3VyYWJsZSBpbiBjb25maWcgcGhhc2VcbiAgICAgICAgICAgIHZhciBDT1JFX0FQSV9FTkRQT0lOVF9TVUZGSVggPSAnYXBpJztcbiAgICAgICAgICAgIHZhciBNQVJLRVRJTkdfQVBJX0VORFBPSU5UX1NVRkZJWCA9ICdhcGknO1xuICAgICAgICAgICAgdmFyIEJsdWVza3lIdHRwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIGN0b3JcbiAgICAgICAgICAgICAgICAvKiBAbmdJbmplY3QgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbHVlc2t5SHR0cFdyYXBwZXIoJGh0dHAsICR3aW5kb3csICRsb2csICRxLCAkbG9jYXRpb24sIFVwbG9hZCwgdG9hc3RlciwgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwsIHNlbGVjdGVkVXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSAtIGZldGNoIHRoZSBjb25maWd1cmF0aW9uIGRhdGEgbmVjZXNzYXJ5IGZvciB0aGlzIHNlcnZpY2UgdG8gcnVuIGZyb20gdGhlIHByb3ZpZGVkIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2luZG93ID0gJHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nID0gJGxvZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcSA9ICRxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2NhdGlvbiA9ICRsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5VcGxvYWQgPSBVcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3RlciA9IHRvYXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnSW5pdGlhbGl6YXRpb25VUkwgPSBjb25maWdJbml0aWFsaXphdGlvblVSTDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gc2VsZWN0ZWRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogUHJlcGFyZXMgYSB7QGxpbmsgbmcjJGh0dHAjY29uZmlnIGNvbmZpZ30gb2JqZWN0IGZvciAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAqICAtIEFqYXggY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgKiAgLSBBdXRob3JpemF0aW9uIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS5cbiAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtuZy4kaHR0cC5jb25maWd9IHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCByZWFkeSB0byBiZSBpbmplY3RlZCBpbnRvIGEgJGh0dHAgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVIdHRwQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVUkwgJiBNRVRIT0QgcGFyYW1ldGVycyBhcmUgbmVjZXNzYXJ5IGZvciBodHRwV3JhcHBlciBjYWxscy4gQWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBjb25maWcgdmFsdWVzIGFuZCBjdXN0b20gb25lcyBiYXNlZCBvbiBlbmRwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgPSBjb25maWcuZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZS5PUklHSU47IC8vIGRlZmF1bHQgdmFsdWU6IGlmIG5vdCBzcGVjaWZpZWQsIGVuZHBvaW50IHRvIHVzZSBpcyBzdXBwb3NlZCB0byBiZSB0aGUgb3JpZ2luLiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBnZXQgYWxsIG5vbi1maWx0ZXJlZCBwYXJhbWV0ZXJzICYga2VlcCB0aGVtIGZvciB0aGlzIG5ldyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnRnVsbCA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHN1cHBvcnQgbWFwcGluZyBiZXR3ZWVuIHVwbG9hZCAmIHBvc3QgaGVyZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLm1ldGhvZCA9IEh0dHBNZXRob2RbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJlIGRlZmF1bHQgY29uZmlnIGZsYWdzIGJhc2VkIG9uIHRhcmdldCBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5DT1JFX0FQSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBsaWNpdGx5IHdyb25nIGlucHV0IGNvbmZpZ3VyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUNvcmVBcGlKd3RBdXRoVG9rZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cud2FybihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBDb3JlQVBJIGNhbGwgaW50ZW5kZWQgd2l0aCBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBBYm9ydGluZyBhamF4IGNhbGwuXCIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWcgdmFsdWVzIGZvciBDb3JlQVBJIGVuZHBvaW50IGFyZSBkaWZmZXJlbnQgZnJvbSBkZWZhdWx0LCBzbyB3ZSBtdXN0IHNwZWNpZnkgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUNvcmVBcGlKd3RBdXRoVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLk1BUktFVElOR19BUEkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuT1JJR0lOIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLlFVT1RFX1dJWkFSRCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5PUkRFUl9FTlRSWSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZS5PUkRFUl9UUkFDS0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBwcm92aWRlIG1vcmUgY29tcGxldGUgZmVlZGJhY2tzIG9uIHRob3NlIHNwZWNpZmljIGVuZHBvaW50cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUNvcmVBcGlKd3RBdXRoVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cud2FybignW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIC0gVXNlclJvbGUgJiBKd3RUb2tlbiBzaG91bGQgbm90IGJlIHByb3ZpZGVkIGZvciB0YXJnZXQgZW5kcG9pbnQuICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLkVYVEVSTkFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IHRydWU7IC8vIGRvIG5vdCBhZGQgWG1sSHR0cFJlcXVlc3QgaWYgZXh0ZXJuYWwgVXJsIGJ5IGRlZmF1bHQ6IG1pZ2h0IGNyZWF0ZSBjb25mbGljdHMgb24gY2VydGFpbiBzZXJ2ZXJzLiBUT0RPIE1HQSB0byBjb25maXJtXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gVW5zdXBwb3J0ZWQgZW5kcG9pbnRUeXBlIHByb3ZpZGVkOiAnXCIgKyBFbmRwb2ludFR5cGVbY29uZmlnLmVuZHBvaW50VHlwZV0gKyBcIicuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNldCBkZWZhdWx0IHZhbHVlcyBhZnRlciBlbmRwb2ludC1zcGVjaWZpYyBjb25maWd1cmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlID0gY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSB8fCBmYWxzZTsgLy8gZGVmYXVsdCB2YWx1ZTogZG9uJ3QgdHJhbnNtaXQgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHRvIHJlbW90ZSBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudXNlQ29yZUFwaUp3dEF1dGhUb2tlbiA9IGNvbmZpZy51c2VDb3JlQXBpSnd0QXV0aFRva2VuIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgPSBjb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zIHx8IGZhbHNlOyAvL3NldCBkZWZhdWx0IHZhbHVlIGZvciBkaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgdG8gZmFsc2UgYXMgaXQncyBwYXJ0IG9mIHRoZSBub3JtYWwgYmVoYXZpb3IgZXhwZWN0ZWQgZm9yIHRoaXMgc2VydmljZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBidWlsZCBhIHZhbGlkIHVybCBmcm9tIGlucHV0ICYgZW5kcG9pbnRUeXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSBfdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgY29uZmlnLmVuZHBvaW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZ0Z1bGwudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSB1cmxJbnB1dCAnXCIgKyB1cmwgKyBcIicgd2l0aCBlbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlW2NvbmZpZy5lbmRwb2ludFR5cGVdICsgXCInLiBBYm9ydGluZyBhamF4IGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGNhbGwgd2hlbiBtaXNzaW5nIG1hbmRhdG9yeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHwgIV90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFtcIiArIGNvbmZpZ0Z1bGwubWV0aG9kICsgXCIgLyBcIiArIHVybCArIFwiXSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSB1c2VyUm9sZSBpbiBibHVlc2t5QWpheENsaWVudENvbmZpZy4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydPQS1Vc2VyUm9sZSddID0gX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY3VycmVudFVzZXJSb2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VDb3JlQXBpSnd0QXV0aFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGNhbGwgd2hlbiBtaXNzaW5nIG1hbmRhdG9yeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHwgIV90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmNvcmVBcGlBdXRoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3Nhcnkgand0VG9rZW4gaW4gYmx1ZXNreUFqYXhDbGllbnRDb25maWcuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY29yZUFwaUF1dGhUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZSwgb3IgYXQgbGVhc3QgcHV0IGluIGFzIGNvbmZpZyBwYXJhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTdWNjZXNzIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBjYWxsaW5nQ29uZmlnOiBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWFrZSB0aGUgYWpheCBjYWxsLCBpbiBjYXNlIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIG51bGwvZW1wdHkgYW5kIGRvZXNuJ3QgY29udGFpbiBuZWNlc3NhcnkgZGF0YSBmb3IgZGVidWdnaW5nLlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzID0gZnVuY3Rpb24gKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3QgaWYgc3RhdHVzICE9IDJYWCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHdoZW4gQVBJIGlzIGZpeGVkLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTc0Njg5NC93aGF0LWlzLXRoZS1wcm9wZXItcmVzdC1yZXNwb25zZS1jb2RlLWZvci1hLXZhbGlkLXJlcXVlc3QtYnV0LWFuLWVtcHR5LWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmICgocHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IG51bGwgfHwgcHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IHVuZGVmaW5lZCkgJiYgcHJvbWlzZUNhbGxiYWNrLnN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnVW5leHBlY3RlZCByZXNwb25zZScsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QocHJvbWlzZUNhbGxiYWNrKTsgLy8gUmVqZWN0IHByb21pc2UgaWYgbm90IHdlbGwtZm9ybWVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzYW1lIGJlaGF2aW9yIGFsc28gb24gYSBHRVQgcmVxdWVzdCA/IGlmIHJlcXVlc3QgaXMgR0VUIGFuZCByZXNwb25zZSBpcyAyMDAgd2l0aCBubyBkYXRhLCByZXR1cm4gZXJyb3IgPyAocGFzcyBpbiBwYXJhbWV0ZXIgcmVxdWVzdCBjb250ZXh0IHRvIGxvZyB0aGlzIGVycm9yKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZGVidWcoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9ubHkgdGhlIGRhdGEgZXhwZWN0ZWQgZm9yIGNhbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodHRwUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IGFuZ3VsYXIgc2lnbmF0dXJlcyBpbmRpY2F0ZXMgdGhhdCBwYXJhbWV0ZXIgaXMgcmVqZWN0aW9uIHJlYXNvbiwgbm90IG5lY2Vzc2FyaWx5IGh0dHBQcm9taXNlOiBpbnZlc3RpZ2F0ZSAmIGZpeCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGh0dHBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQTogbWF5IGFsc28gYmUgYSBmYXVsdCBpbiBpbnRlcm5hbCAkaHR0cCAvIGFqYXggY2xpZW50IHNpZGUgbGliLCB0byBkaXN0aW5ndWlzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlIHx8ICFodHRwUHJvbWlzZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2Uuc3RhdHVzID0gNTAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUHJvbWlzZS5oZWFkZXJzKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBjb250ZW50VHlwZSB0byB0cnkgdG8gZGlzcGxheSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCI7IC8vZGVmYXVsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgZXJyb3IgaGFuZGxpbmcgbW9yZSBnZW5lcmljYWxseSBiYXNlZCBvbiBpbnB1dCBlcnJvciBtZXNzYWdlIGNvbnRyYWN0IGluc3RlYWQgb2YgZXhwZWN0aW5nIHNwZWNpZmljIGVycm9yIHN0cmN0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltIVFRQIFwiICsgaHR0cFByb21pc2UuY29uZmlnLm1ldGhvZCArIFwiXSBbXCIgKyBodHRwUHJvbWlzZS5jb25maWcudXJsICsgXCJdXCIsIGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZWNvdmVyIGZyb20gZXJyb3IsIHNvIHdlIHByb3BhZ2F0ZSBpdCA6IGJlbG93IGhhbmRsZXJzIGhhdmUgdGhlIGNob2ljZSBvZiByZWFkaW5nIHRoZSBlcnJvciB3aXRoIGFuIGVycm9yIGhhbmRsZXIgb3Igbm90LiBTZWUgJHEgcHJvbWlzZXMgYmVoYXZpb3IgaGVyZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFqYXggY2FsbCwgcmVnYXJkbGVzcyBvZiBpdCdzIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBIGludmVyc2lvbiBvZiByZXNwb25zYWJpbGl0eTogbWFrZSB0aGlzIGV4dGVuc2libGUgc28gdGhhdCBzcGVjaWZjIGFwcHMgY2FuIHBsdWcgaW50byB0aGlzIGV2ZW50IHdvcmtmbG93XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHdpbmRvdy5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHdpbmRvdy5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlndXJhdGlvbkVuZHBvaW50VXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KGNvbmZpZ0luaXRpYWxpemF0aW9uVVJMLCBFbmRwb2ludFR5cGUuT1JJR0lOKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJyB3aXRoIGVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVbRW5kcG9pbnRUeXBlLk9SSUdJTl0gKyBcIicuIEFib3J0aW5nIGJsdWVza3lIdHRwU2VydmljZSBpbml0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbmZpZ1Byb21pc2UgPSB0aGlzLiRodHRwLmdldChjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2xpZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IHN0YXR1cyBub3QgaW4gMlhYID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiVW5hYmxlIHRvIHJldHJpZXZlIGh0dHAgY29uZmlnIGRhdGEgZnJvbSAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdG9hc3RlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgPSBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGJsdWVza3lDbGllbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBjYXNlIHdoZXJlIGNsaWVudC1zaWRlIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBhbmQgbm90ID09IHNydi1zaWRlIHVzZXIgcm9sZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsdWVza3lDbGllbnRDb25maWcuY3VycmVudFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBub3QgcHJvdmlkZWQgYnkgZG9tYWluIGZyb20gd2hpY2ggY29kZSB3YXMgbG9hZGVkLCB0aGVuIHRyeSB0byBmZXRjaCBkZWZhdWx0IHVzZXJSb2xlIGZyb20gQ0FQSSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQoJ3VzZXItc3NvP3Byb2ZpbGU9JywgeyBlbmRwb2ludFR5cGU6IEVuZHBvaW50VHlwZS5DT1JFX0FQSSB9KS50aGVuKGZ1bmN0aW9uICh1c2VyU3NvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlclNzbyB8fCAhdXNlclNzby51c2VyUm9sZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ1VuYWJsZSB0byByZXRyaWV2ZSBDb3JlQVBJIGRlZmF1bHQgdXNlclNTTy4gQWJvcnRpbmcgaHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJSb2xlVG9Vc2UgPSBzZWxlY3RlZFVzZXJSb2xlIHx8IHVzZXJTc28udXNlclJvbGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdGhpcyBuZWVkcyB0byBiZSBwdXQgaW4gc2hhcmVkIGV4dGVuc2lvbiBtZXRob2QgLyBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UubmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5yb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLnNpbG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyID0gdXNlclNzbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB3ZSBvbmx5IGxvYWQgdXNlclNTTyBpZiBubyB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgc3J2LXNpZGUsIHNob3VsZCB3ZSBsb2FkIGl0IGluIGFsbCBjYXNlcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkIHVzZXJSb2xlIHNlbnQgZnJvbSBvcmlnaW4gYXBwLCB1c2UgaXQgJiBzZXQgaXQgYXMgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgbWV0aG9kc1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5ERUxFVEUsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh1cmwsIGZpbGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXBsb2FkSW5CYXNlNjRKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgdGhpcyBkZWxheXMgbmV4dCBjYWxsIGFuZCB1cGxvYWQgaXMgbm90IGRvbmUgYmVmb3JlIGJhc2U2NCBlbmNvZGluZyBpcyBmaW5pc2hlZCwgZXZlbiBpZiBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQgPz8/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQuYmFzZTY0RGF0YVVybChmaWxlKS50aGVuKGZ1bmN0aW9uIChmaWxlQmFzZTY0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZC1jb2RlZCBrZXkgdG8gZmV0Y2ggYmFzZTY0IGVuY29kaW5nLCB0byBwYXJhbWV0cml6ZSB3aXRoIHNlcnZlci1zaWRlICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlQmFzZTY0VXJsID0gZmlsZUJhc2U2NFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbCBwb3N0IGluIGNhc2Ugb2YgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSA/IChpbml0Q2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGJlaGF2aW9yIGR1cGxpY2F0aW9uIHdpdGggdGhpcy5hamF4LCBub3QgRFJZLCB0byBpbXByb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLlVwbG9hZC51cGxvYWQocmVxdWVzdENvbmZpZykgLy9UT0RPIE1HQSA6IG5vdCBzYWZlIGhhcmQgY2FzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMub25TdWNjZXNzKGNvbmZpZyksIF90aGlzLm9uRXJyb3IoY29uZmlnKSwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vVE9ETyBNR0E6IHdoYXQgdG8gcmV0dXJuID9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRvd25sb2FkIGEgZmlsZSBpbiB0aGUgZm9ybSBvZiBhIGJ5dGUtc3RyZWFtIGZyb20gYW4gZW5kcG9pbnQgYW5kIHdyYXAgaXQgaW50byBhIEZpbGVDb250ZW50IG9iamVjdCB3aXRoIG5hbWUsIHR5cGUgJiBzaXplIHByb3BlcnRpZXMgcmVhZCBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIHNlcnZldXIuXG4gICAgICAgICAgICAgICAgICogSXQgaXMgdGhlIHJlc3BvbnNhYmlsaXR5IG9mIHRoZSBjb25zdW1lciB0byBkbyBzb21ldGhpbmcgd2l0aCB0aGUgd3JhcHBlZCBieXRlQXJyYXkgKGZvciBleGFtcGxlIGRvd25sb2FkIHRoZSBmaWxlLCBvciBzaG93IGl0IGluc2lkZSB0aGUgd2ViUGFnZSBldGMpLlxuICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWROYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkU2l6ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRGaWxlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFySHR0cENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoJ1VuYWJsZSB0byBjb25maWd1cmUgcmVxdWVzdCBjb3JyZWN0bHkuIEFib3J0aW5nIGdldEZpbGUgYWpheCBjYWxsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRXhwZWN0ZWQgQXJyYXlCdWZmZXIgcmVzcG9uc2UgPSBieXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmVuZWZpdCBmcm9tIHN1Y2Nlc3NDYWxsYmFjayB2YWxpZGF0aW9uIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gX3RoaXMub25TdWNjZXNzKGNvbmZpZykoaHR0cFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBwcm9taXNlIHJlamVjdGlvbiB2cy4gcmV0dXJuIG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVhZCBmaWxlIGluZm8gZnJvbSByZXNwb25zZS1oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTnVtYmVyKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWxlbmd0aCcpKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5vbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxuICAgICAgICAgICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKVxuICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gbnVsbCBpZiBub3QgYWJsZSB0byBjb21wdXRlIHVybC4gT3RoZXJ3aXNlLCB1cmwgb2YgdGhlIHJlcXVlc3QgZWl0aGVyIHBhcnRpYWwgb3IgZnVsbCBiYXNlZCBvbiBlbmRwb2ludFR5cGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5idWlsZFVybEZyb21Db250ZXh0ID0gZnVuY3Rpb24gKHVybElucHV0LCBlbmRwb2ludFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmxJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdObyBVUkwgaW5wdXQgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGhhdmUgYSBwYXJ0aWFsIFVSTCB0byBjb21wbGV0ZTogdXNlIHByb3ZpZGVkIGVuZHBvaW50IHR5cGUgdG8gZGV0ZXJtaW5lIGhvdyB0byBjb21wbGV0ZSB1cmwuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIGVuZHBvaW50VHlwZSBpZiBub3QgcHJvdmlkZWQgaXMgb3JpZ2luLiBUT0RPIE1HQTogcnVsZSB0byBkaXNjdXNzLCBoZXJlIGZvciByZXRyby1jb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludFR5cGUgPSBlbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlLk9SSUdJTjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLkVYVEVSTkFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignUGFydGlhbCB1cmwgcHJvdmlkZWQgZm9yIGFuIGV4dGVybmFsIGVuZHBvaW50OiB0aGUgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgbW9kaWZ5IHByb3ZpZGVkIHVybCBpZiBleHRlcm5hbCAod2UgY2Fubm90IGtub3cgaG93IHRvIGNvbXBsZXRlIGl0LCBldmVuIGlmIHBhcnRpYWwpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9Db21wdXRlIHVybCBhcyBjb21iaW5hdGlvbiBvZiBiYXNlIHVybCAmIHVybCBmcmFnbWVudCBnaXZlbiBhcyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLkNPUkVfQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmNvcmVBcGlVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIGNvcmVBcGlVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5jb3JlQXBpVXJsICsgQ09SRV9BUElfRU5EUE9JTlRfU1VGRklYO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuTUFSS0VUSU5HX0FQSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyB8fCAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5tYXJrZXRpbmdBcGlVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIG1hcmtldGluZ0FwaVVybCBpbiBCbHVlc2t5QWpheENsaWVudENvbmZpZy4gY2Fubm90IGJ1aWxkIHZhbGlkIHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm1hcmtldGluZ0FwaVVybCArIE1BUktFVElOR19BUElfRU5EUE9JTlRfU1VGRklYO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGUuUVVPVEVfV0laQVJEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLnF1b3RlV2l6YXJkVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignTWlzc2luZyBxdW90ZVdpemFyZFVybCBpbiBCbHVlc2t5QWpheENsaWVudENvbmZpZy4gY2Fubm90IGJ1aWxkIHZhbGlkIHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIHdpbGwgcHJvYmFibHkgZmFpbCAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5xdW90ZVdpemFyZFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLk9SREVSX0VOVFJZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm9yZGVyRW50cnlVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIG9yZGVyRW50cnlVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaGFuZGxlIE9NIGFwcHMgZXh0ZXJuYWwgY2FsbHMgd2l0aG91dCBzZXNzaW9uIHByb3ZpZGVkID8gd2lsbCByZXN1bHQgaW4gYSByZWRpcmVjdCBhbmQgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcub3JkZXJFbnRyeVVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLk9SREVSX1RSQUNLSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8ICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLm9yZGVyVHJhY2tpbmdVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdNaXNzaW5nIG9yZGVyVHJhY2tpbmdVcmwgaW4gQmx1ZXNreUFqYXhDbGllbnRDb25maWcuIGNhbm5vdCBidWlsZCB2YWxpZCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaGFuZGxlIE9NIGFwcHMgZXh0ZXJuYWwgY2FsbHMgd2l0aG91dCBzZXNzaW9uIHByb3ZpZGVkID8gd2lsbCByZXN1bHQgaW4gYSByZWRpcmVjdCBhbmQgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcub3JkZXJUcmFja2luZ1VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9UT0RPIE1HQTogaGFuZGxlIG90aGVyIGVuZHBvaW50cyAhISEgVEksIE1OLCBURyBldGNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlLk9SSUdJTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVySXNQcmVzZW50UmVnZXggPSAvXFx3K1xcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5zdXBwb3J0ZWQgZW5kcG9pbnRUeXBlIHByb3ZpZGVkLiBTaG91bGQgbm90IGhhcHBlbiAoZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZSBPcmlnaW4pLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gdXNlZCB0byB0cnkgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgZnVsbCB1cmwgKGFkZCAvIG9yIG5vdCBiZWZvcmUgdGhlIHVybCBmcmFnbWVudCBkZXBlbmRpbmcgb24gaWYgZm91bmQgb3Igbm90KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgMSkgPT09ICcvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoID0gYmFzZVVybC5zbGljZShiYXNlVXJsLmxlbmd0aCAtIDEsIGJhc2VVcmwubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlZCBvbiBzdGFydGluZy90cmFpbGluZyBzbGFzaGVzLCByZXR1cm4gZnVsbCB1cmwuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsLnNsaWNlKDAsIGJhc2VVcmwubGVuZ3RoIC0gMSkgKyB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgIXVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuYWpheCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChtZXRob2QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFySHR0cENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2Vzcyhjb25maWcpLCBfdGhpcy5vbkVycm9yKGNvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0VXJsUGF0aCA9IGZ1bmN0aW9uIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE1hdGNoZXMgPSBiYXNlVXJsUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybE1hdGNoZXMgJiYgYmFzZVVybE1hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsTWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsID0gYmFzZVVybE1hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPTS1zcGVjaWZpYyBBU1AgTVZDIGNvZGUsIG5vdCB1c2VkIEFUTSwgdG8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRDdXJyZW50U2Vzc2lvbklEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFnaWMgcmVnZXhwIHRvIGZldGNoIFNlc3Npb25JRCBpbiBVUkwsIHRvIHN0b3JlIGVsc2V3aGVyZSAhXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uUmVnZXggPSAvaHR0cHM6XFwvXFwvW1xcdy5dK1xcL1tcXHcuXStcXC8oXFwoU1xcKFxcdytcXClcXCkpXFwvLiovO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBzZXNzaW9uUmVnZXggPSAvaHR0cHM6XFwvXFwvW1xcdy5dK1xcL09yZGVyRW50cnlcXC8oXFwoU1xcKFxcdytcXClcXCkpXFwvLiovO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVwZGF0ZSByZWdleHAgdG8gdGhlIG9uZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBiYXNlVXJsUmVnZXggPSAvKGh0dHBzOlxcL1xcL1tcXHcuLV0rXFwvW1xcdy4tXStcXC9cXChTXFwoXFx3K1xcKVxcKVxcLylcXHcrLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLiRsb2NhdGlvbi5hYnNVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4cEFycmF5ID0gc2Vzc2lvblJlZ2V4LmV4ZWMocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cEFycmF5WzFdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVHJpbSB0aGUgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgdG8gcmV0dXJuIG9ubHkgdGhlIGZpbGVuYW1lLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb250ZW50RGlzcG9zaXRpb25IZWFkZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEZpbGVOYW1lRnJvbUhlYWRlckNvbnRlbnREaXNwb3NpdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbHVlc2t5SHR0cFdyYXBwZXI7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyID0gQmx1ZXNreUh0dHBXcmFwcGVyO1xuICAgICAgICB9KShzZXJ2aWNlcyA9IGNvcmUuc2VydmljZXMgfHwgKGNvcmUuc2VydmljZXMgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
