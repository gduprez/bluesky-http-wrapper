



var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            /**
             * Provider for the BlueskyHttpWrapper.
             * Enables per-consumer configuration of the http service to set custom configuration URL to fetch data from:
             *  - Client initial configuration URL from the origin the app was loaded from.
             *  - UserRole to use of already fetched from another place.
             */
            var BlueskyHttpWrapperProvider = (function () {
                function BlueskyHttpWrapperProvider() {
                    var _this = this;
                    //#region private properties
                    this.getClientConfigInitializationUrl = 'BlueskyAjaxClientConfiguration/GetAjaxClientConfiguration'; // by default.
                    this.selectedUserRole = null; // by default not-set.
                    //#endregion
                    // Provider's factory function
                    /* @ngInject */
                    this.$get = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", function (_, $http, $window, $log, $q, $location, Upload, toaster) {
                        return new services.BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, _this.getClientConfigInitializationUrl, _this.selectedUserRole);
                    }];
                    this.$get.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                }
                //#endregion
                //#region public configuration methods
                BlueskyHttpWrapperProvider.prototype.setClientConfigURL = function (clientConfigUrlToUse) {
                    this.getClientConfigInitializationUrl = clientConfigUrlToUse || this.getClientConfigInitializationUrl;
                };
                BlueskyHttpWrapperProvider.prototype.setUserRoleToUse = function (userRole) {
                    this.selectedUserRole = userRole || null;
                };
                return BlueskyHttpWrapperProvider;
            }());
            services.BlueskyHttpWrapperProvider = BlueskyHttpWrapperProvider;
            angular.module('bluesky.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .constant('_', window._)
                .constant('moment', window.moment)
                .provider('blueskyHttpWrapper', BlueskyHttpWrapperProvider);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var EndpointTypeEnum = bluesky.core.models.clientConfig.EndpointTypeEnum;
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            var BlueskyHttpWrapper = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                BlueskyHttpWrapper.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", "configInitializationURL", "selectedUserRole"];
                function BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, configInitializationURL, selectedUserRole) {
                    // 1 - fetch the configuration data necessary for this service to run from the provided endpoint
                    var _this = this;
                    this._ = _;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    this.configInitializationURL = configInitializationURL;
                    this.selectedUserRole = selectedUserRole;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        // input validation
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        // set default config values and custom ones based on endpoints
                        config = config || {};
                        config.endpointType = config.endpointType || EndpointTypeEnum.CurrentDomain; // default value: if not specified, endpoint to use is supposed to be the origin.
                        // search by string representation of endpoint type
                        // TODO MGA: make sure EndpointTypeEnum[invalid value] doesn't return default valid enum value ??? otherwise, dangerous !
                        var currentEndpointConfig = _this.blueskyAjaxClientConfig && _this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[config.endpointType]];
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        configFull.headers = config.headers || {};
                        // configure default config flags based on target endpoint
                        switch (config.endpointType) {
                            case EndpointTypeEnum.CoreApi:
                            case EndpointTypeEnum.MarketingApi:
                            case EndpointTypeEnum.SelfcareApi:
                                // Reject explicitly wrong input configurations
                                if (config.disableXmlHttpRequestHeader) {
                                    _this.$log.warn("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - API call intended with incompatible configuration options. Aborting ajax call.", config);
                                    return null;
                                }
                                // config values for API endpoints are different from default, so we must specify them.
                                config.disableXmlHttpRequestHeader = false; // by default already enabled, but enfore this header as necessary for calls to WebAPI endpoints.
                                config.useCurrentUserRole = true; // for api calls, force this role to be passed around (should be mandatory to contextualize request to realm of current user).
                                break;
                            case EndpointTypeEnum.QuoteWizard:
                            case EndpointTypeEnum.OrderEntry:
                            case EndpointTypeEnum.OrderTracking:
                                // for OM apps called as endpoints, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                //TODO MGA: add currentUserRole by default so that OM apps can contextualise the request ?
                                break;
                            case EndpointTypeEnum.Metranet:
                            case EndpointTypeEnum.TechnicalInventory:
                            case EndpointTypeEnum.TemplateGenerator:
                            case EndpointTypeEnum.Salesforce:
                                //TODO MGA: no specific config for those external endpoints ? add custom ones if needed here.
                                break;
                            case EndpointTypeEnum.CurrentDomain:
                                // for ajax calls, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                break;
                            case EndpointTypeEnum.External:
                                //TODO MGA to confirm
                                config.disableXmlHttpRequestHeader = true; // do not add XmlHttpRequest if external Url by default: might create conflicts on certain servers.
                                break;
                            default:
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Unsupported endpointType provided: '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.");
                                return null;
                        }
                        //Reject ajax calls intended to external endpoints without necessary configuration loaded from the server.
                        if (config.endpointType !== EndpointTypeEnum.CurrentDomain &&
                            config.endpointType !== EndpointTypeEnum.External &&
                            !currentEndpointConfig) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without expected endpoint configuration loaded from the server for endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.");
                            return null;
                        }
                        //TODO MGA: set default values after endpoint-specific configurations
                        config.disableXmlHttpRequestHeader = config.disableXmlHttpRequestHeader || false; // default value is enabled (ajax calls on .NET endpoints).
                        config.useCurrentUserRole = config.useCurrentUserRole || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.disableToasterNotifications = config.disableToasterNotifications || false; //set default value for disableToasterNotifications to false as it's part of the normal behavior expected for this service.
                        // Try to build a valid url from input & endpointType.
                        configFull.url = _this.buildUrlFromContext(url, config.endpointType);
                        if (!configFull.url) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] - Unable to build url from urlInput '" + url + "' with endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting ajax call.");
                            return null;
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        if (config.useCurrentUserRole) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig.CurrentUserRole) {
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without necessary userRole set in config. Aborting.");
                                return null;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['OA-UserRole'] = _this.blueskyAjaxClientConfig.CurrentUserRole;
                        }
                        // If auth token provided for target endpoint, add it in header
                        if (currentEndpointConfig.AuthToken) {
                            //TODO MGA: reject authToken for endpoints that are not 'safe' to share auth token with, such as External ones ? Or authorize this so that server can load an auth token for certain external endpoints ?
                            //TODO MGA: handle token validity endDate: renew auth before the call ! What's the best moment to do it ?
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['Authorization'] = 'Bearer ' + currentEndpointConfig.AuthToken;
                        }
                        //TODO MGA: OE specific code, to remove, or at least put in as config param
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (originalConfig) {
                        return function (httpPromise) {
                            if (!httpPromise) {
                                _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                                if (!originalConfig.disableToasterNotifications)
                                    _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                                return null;
                            }
                            //TODO MGA: reject if status != 2XX ?
                            //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                            //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                            //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                            //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                            //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                            //}
                            //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                            //TODO MGA: get full url of request
                            _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // return only the data expected for caller
                            return httpPromise.data;
                        };
                    };
                    /**
                     * Error handler
                     * TODO MGA: angular signatures indicates that parameter is rejection reason, not necessarily httpPromise: investigate & fix if necessary
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (originalConfig) {
                        return function (httpPromise) {
                            // We suppose in case of no response that the srv didn't send any response.
                            // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                            if (!httpPromise || !httpPromise.data) {
                                httpPromise.data = 'Server not responding';
                                httpPromise.status = 503;
                            }
                            if (!originalConfig.disableToasterNotifications) {
                                var contentType = httpPromise.headers('Content-Type');
                                //check contentType to try to display error message
                                if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                                    var message = ""; //default message
                                    //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                                    //if (response.data.ModelState) {
                                    //    //TODO MGA : handle this when well formatted server-side
                                    //} else
                                    if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                        message = httpPromise.data.Message;
                                    }
                                    else if (angular.isString(httpPromise.data)) {
                                        message = httpPromise.data;
                                    }
                                    //TODO MGA: handle more response codes gracefully.
                                    if (httpPromise.status === 404) {
                                        _this.toaster.warning('Not Found', message);
                                    }
                                    else {
                                        _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                                    }
                                }
                                else {
                                    _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                                }
                            }
                            //TODO MGA: get full url of request
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                            // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                            return _this.$q.reject(httpPromise);
                        };
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     * TODO MGA inversion of responsability: make this extensible so that specifc apps can plug into this event workflow
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    var configurationEndpointUrl = this.buildUrlFromContext(configInitializationURL, EndpointTypeEnum.CurrentDomain);
                    if (!configurationEndpointUrl) {
                        this.$log.error("[BlueskyHttpWrapper][Initialization] - Unable to build url from initialConfig url '" + configInitializationURL + "' with endpointType '" + EndpointTypeEnum[EndpointTypeEnum.CurrentDomain] + "'. Aborting blueskyHttpService init.");
                        return;
                    }
                    //TODO MGA: custom config for headers hard coded, to mutualize with const
                    this.getConfigPromise = this.$http.get(configurationEndpointUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
                        .then(
                    // success
                    function (clientConfigPromise) {
                        //TODO MGA: reject status not in 2XX ?
                        if (!clientConfigPromise.data) {
                            var msg = "Unable to retrieve http config data from '" + configInitializationURL + "'. Aborting blueskyHttpWrapperService initialization.";
                            _this.$log.error(msg);
                            //TODO MGA: toaster ?
                            return _this.$q.reject(msg);
                        }
                        _this.blueskyAjaxClientConfig = clientConfigPromise.data;
                        return clientConfigPromise.data;
                    }, 
                    // error
                    function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting blueskyHttpWrapperService initialization. Srv msg: ', error);
                        //TODO MGA: show toaster ? based on provider config flag ?
                        return _this.$q.reject(error);
                    })
                        .then(
                    // success
                    function (blueskyClientConfig) {
                        //TODO MGA: handle case where client-side userRole was provided and not == srv-side user role !
                        if (!blueskyClientConfig.CurrentUserRole) {
                            //If not provided by domain from which code was loaded, then try to fetch default userRole from CAPI endpoint
                            return _this.get('user-sso?profile=', { endpointType: EndpointTypeEnum.CoreApi }).then(function (userSso) {
                                if (!userSso || !userSso.UserRoleEntry) {
                                    var msg = 'Unable to retrieve CoreAPI default userSSO. Aborting httpWrapperService initialization.';
                                    _this.$log.error(msg);
                                    return _this.$q.reject(msg);
                                }
                                //TODO MGA: make sure selectedUserRole is available in the list of userSSO roles, otherwise select default !
                                //TODO MGA: how to inform back the DA that selectedUserRole was reset ? invert responsability & store userRole in localStorage from this service ?
                                var userRoleToUse = selectedUserRole || userSso.UserRoleEntry;
                                //TODO MGA: this needs to be put in shared extension method / service
                                _this.blueskyAjaxClientConfig.CurrentUserRole = userRoleToUse.Name + " " + userRoleToUse.Role + " " + userRoleToUse.Silo;
                                _this.blueskyAjaxClientConfig.CurrentUser = userSso;
                                return blueskyClientConfig;
                            });
                        }
                        else {
                            //TODO MGA: we only load userSSO if no userRole was provided srv-side, should we load it in all cases ?
                            // already defined userRole sent from origin app, use it & set it as default.
                            return blueskyClientConfig;
                        }
                    });
                }
                //#endregion
                //#region public methods
                BlueskyHttpWrapper.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                BlueskyHttpWrapper.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                BlueskyHttpWrapper.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                BlueskyHttpWrapper.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                /**
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param file
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IBlueskyHttpRequestConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API ? (initCall)
                        return this.getConfigPromise.then(function () {
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            var requestConfig = _this.configureHttpCall(HttpMethod.POST, url, config);
                            if (requestConfig)
                                return _this.Upload.upload(requestConfig) //TODO MGA : not safe hard cast
                                    .then(_this.onSuccess(config), _this.onError(config), config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                    .finally(_this.finally);
                            return null; //TODO MGA: what to return ?
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // if no config returned, configuration failed, do not start ajax request
                        if (!angularHttpConfig) {
                            return _this.$q.reject('Unable to configure request correctly. Aborting getFile ajax call.');
                        }
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(config)(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 * @return null if not able to compute url. Otherwise, url of the request either partial or full based on endpointType.
                 */
                BlueskyHttpWrapper.prototype.buildUrlFromContext = function (urlInput, endpointType) {
                    if (!urlInput) {
                        this.$log.error('No URL input provided.');
                        return null;
                    }
                    // If Url starts with http:// or https:// => return as is, even if endpointType is not external.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        if (endpointType !== EndpointTypeEnum.External)
                            this.$log.warn('Full URL provided for a call that is not flagged as \'External\' endpointType, this is bad practice as only the blueskyWrapper should know about the baseURL of target endpoints (loaded from server, depending on the current env). Use partial URLs.');
                        return urlInput;
                    }
                    // Else, we have a partial URL to complete: use provided endpoint type to determine how to complete url.
                    // Default value for endpointType if not provided is origin. TODO MGA: rule to discuss, here for retro-compatibility.
                    endpointType = endpointType || EndpointTypeEnum.CurrentDomain;
                    var baseUrl;
                    if (endpointType === EndpointTypeEnum.External) {
                        this.$log.warn('Partial url provided for a call with endpointType flagged as \'External\': the call will probably fail.');
                        // do not modify provided url if external (we cannot know how to complete it, even if partial).
                        return urlInput;
                    }
                    else if (endpointType === EndpointTypeEnum.CurrentDomain) {
                        // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                        var controllerIsPresentRegex = /\w+\/\w+/;
                        var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                        baseUrl = this.getUrlPath(actionIsOnSameController);
                    }
                    else {
                        // For all other endpointTypes: compute URL as a combination of baseURL & suffix if present, as provided by server-configuration.
                        if (!this.blueskyAjaxClientConfig ||
                            !this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary) {
                            this.$log.error('Expected endpointConfigurationDictionnary provided but none found. Aborting.');
                            return null;
                        }
                        // TODO MGA HACKY: search by string representation of endpoint type in dict due to serialization limits
                        var endpointConfig = this.blueskyAjaxClientConfig.EndpointConfigurationDictionnary[EndpointTypeEnum[endpointType]];
                        if (!endpointConfig) {
                            this.$log.error("EndpointType '" + EndpointTypeEnum[endpointType] + "' is not 'External' or 'CurrentDomain', expected corresponding endpointConfiguration provided in blueskyAjaxClientConfig.endpointConfigurationDictionnary but none found. Aborting.");
                            return null;
                        }
                        baseUrl = endpointConfig.EndpointBaseURL + (endpointConfig.EndpointSuffix || '');
                    }
                    //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call may fail ?
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, 1) === '/';
                    var baseUrlFragmentEndsWithSlash = baseUrl.slice(baseUrl.length - 1, baseUrl.length) === '/';
                    //based on starting/trailing slashes, return full url.
                    if (baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash)
                        // remove last '/' on baseUrl
                        return baseUrl.slice(0, baseUrl.length - 1) + urlInput;
                    else if (!baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash)
                        return baseUrl + '/' + urlInput;
                    else if ((baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash) ||
                        (!baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash))
                        return baseUrl + urlInput;
                    return null;
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure getConfig resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        if (angularHttpConfig)
                            return _this.$http(angularHttpConfig)
                                .then(_this.onSuccess(config), _this.onError(config))
                                .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                BlueskyHttpWrapper.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = null;
                    var baseUrl = null;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                BlueskyHttpWrapper.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                BlueskyHttpWrapper.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return BlueskyHttpWrapper;
            }());
            services.BlueskyHttpWrapper = BlueskyHttpWrapper;
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGVscy9ibHVlc2t5LWh0dHAtcmVxdWVzdC1jb25maWcubW9kZWwudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5wcm92aWRlci50cyIsImJsdWVza3ktaHR0cC13cmFwcGVyLnNlcnZpY2UudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFxQkM7Ozs7QUNyQkQsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxVQUFTOzs7Ozs7O1lBUzVCLElBQUEsOEJBQUEsWUFBQTtnQkFBQSxTQUFBLDZCQUFBO29CQUFBLElBQUEsUUFBQTs7b0JBSVksS0FBQSxtQ0FBMkM7b0JBQzNDLEtBQUEsbUJBQXFDOzs7O29CQWtCdEMsS0FBQSxpRkFBTyxVQUFDLEdBQ1gsT0FDQSxTQUNBLE1BQ0EsSUFDQSxXQUNBLFFBQ0EsU0FBa0M7d0JBRWxDLE9BQU8sSUFBSSxTQUFTLG1CQUFtQixHQUFHLE9BQU8sU0FBUyxNQUFNLElBQUksV0FBVyxRQUFRLFNBQVMsTUFBSyxrQ0FBa0MsTUFBSzs7Ozs7O2dCQXJCekksMkJBQUEsVUFBQSxxQkFBUCxVQUEwQixzQkFBNEI7b0JBQ2xELEtBQUssbUNBQW1DLHdCQUF3QixLQUFLOztnQkFHbEUsMkJBQUEsVUFBQSxtQkFBUCxVQUF3QixVQUEwQjtvQkFDOUMsS0FBSyxtQkFBbUIsWUFBWTs7Z0JBa0I1QyxPQUFBOztZQWxDYSxTQUFBLDZCQUEwQjtZQW9DdkMsUUFBUSxPQUFPLHVCQUF1QixDQUFDLFdBQVcsYUFBYTtpQkFDMUQsU0FBMkIsS0FBSyxPQUFPO2lCQUN2QyxTQUE4QixVQUFVLE9BQU87aUJBQy9DLFNBQVMsc0JBQXNCO1dBaERqQixXQUFBLEtBQUEsYUFBQSxLQUFBLFdBQVE7T0FBYixPQUFBLFFBQUEsU0FBQSxRQUFBLE9BQUk7R0FBWixZQUFBLFVBQU87O0FDQWpCLElB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T0FBTzs7b0JBR1gsT0FBTzs7O2dCQUlILG1CQUFBLFVBQUEsc0JBQVIsWUFBQTs7b0JBR0ksSUFBSSxlQUFlOzs7O29CQU9uQixJQUFJLE9BQU8sS0FBSyxVQUFVO29CQUUxQixJQUFJLGNBQWMsYUFBYSxLQUFLO29CQUVwQyxJQUFJLENBQUMsYUFBYTt3QkFDZCxLQUFLLEtBQUssTUFBTTt3QkFDaEIsT0FBTzs7b0JBRVgsSUFBSSxZQUFZLFdBQVcsR0FBRzt3QkFDMUIsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUVYLElBQUksWUFBWSxTQUFTLEdBQUc7d0JBQ3hCLEtBQUssS0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFHWCxPQUFPLFlBQVk7Ozs7OztnQkFPZixtQkFBQSxVQUFBLDBDQUFSLFVBQWdELDBCQUFnQztvQkFDNUUsSUFBSSxDQUFDO3dCQUEwQixPQUFPO29CQUV0QyxJQUFJLFNBQVMseUJBQXlCLE1BQU0sS0FBSyxHQUFHLE9BQU8sTUFBTSxLQUFLO29CQUV0RSxPQUFPLE9BQU8sUUFBUSxNQUFNOztnQkFJcEMsT0FBQTs7WUE3bkJhLFNBQUEscUJBQWtCO1dBckNaLFdBQUEsS0FBQSxhQUFBLEtBQUEsV0FBUTtPQUFiLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBQ2drQmpCIiwiZmlsZSI6ImJsdWVza3ktaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQge1xyXG5cclxuICAgIGltcG9ydCBFbmRwb2ludFR5cGVFbnVtID0gY29yZS5tb2RlbHMuY2xpZW50Q29uZmlnLkVuZHBvaW50VHlwZUVudW07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSBEb2NcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnIGV4dGVuZHMgbmcuSVJlcXVlc3RTaG9ydGN1dENvbmZpZyB7XHJcblxyXG4gICAgICAgIGVuZHBvaW50VHlwZT86IEVuZHBvaW50VHlwZUVudW07XHJcblxyXG4gICAgICAgIHVzZUN1cnJlbnRVc2VyUm9sZT86IGJvb2xlYW47XHJcbiAgICAgICAgZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyPzogYm9vbGVhbjtcclxuICAgICAgICBkaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xyXG5cclxuICAgICAgICAvL1RPRE8gTUdBOiBlbmNhcHN1bGF0ZSBpbiBhbiBVcGxvYWRDb25maWcgb2JqZWN0XHJcbiAgICAgICAgZmlsZT86IEZpbGUsXHJcbiAgICAgICAgdXBsb2FkSW5CYXNlNjRKc29uPzogYm9vbGVhbjtcclxuICAgICAgICB1cGxvYWRQcm9ncmVzcz86ICgpID0+IGFueTtcclxuXHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2VzIHtcclxuICAgIGltcG9ydCBVc2VyUm9sZUVudHJ5RHRvID0gYmx1ZXNreS5jb3JlLm1vZGVscy51c2VyTWFuYWdlbWVudC5JVXNlclJvbGVFbnRyeUR0bztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxyXG4gICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxyXG4gICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxyXG4gICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciBpbXBsZW1lbnRzIG5nLklTZXJ2aWNlUHJvdmlkZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw6IHN0cmluZyA9ICdCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb24vR2V0QWpheENsaWVudENvbmZpZ3VyYXRpb24nOyAvLyBieSBkZWZhdWx0LlxyXG4gICAgICAgIHByaXZhdGUgc2VsZWN0ZWRVc2VyUm9sZTogVXNlclJvbGVFbnRyeUR0byA9IG51bGw7IC8vIGJ5IGRlZmF1bHQgbm90LXNldC5cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgY29uZmlndXJhdGlvbiBtZXRob2RzXHJcblxyXG4gICAgICAgIHB1YmxpYyBzZXRDbGllbnRDb25maWdVUkwoY2xpZW50Q29uZmlnVXJsVG9Vc2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsID0gY2xpZW50Q29uZmlnVXJsVG9Vc2UgfHwgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzZXRVc2VyUm9sZVRvVXNlKHVzZXJSb2xlOiBVc2VyUm9sZUVudHJ5RHRvKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSA9IHVzZXJSb2xlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZXIncyBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgcHVibGljICRnZXQgPSAoXzogVW5kZXJzY29yZVN0YXRpYyxcclxuICAgICAgICAgICAgJGh0dHA6IG5nLklIdHRwU2VydmljZSxcclxuICAgICAgICAgICAgJHdpbmRvdzogbmcuSVdpbmRvd1NlcnZpY2UsXHJcbiAgICAgICAgICAgICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkcTogbmcuSVFTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkbG9jYXRpb246IG5nLklMb2NhdGlvblNlcnZpY2UsXHJcbiAgICAgICAgICAgIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHRvYXN0ZXI6IG5ndG9hc3Rlci5JVG9hc3RlclNlcnZpY2UpOiBzZXJ2aWNlcy5JQmx1ZXNreUh0dHBXcmFwcGVyID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIsIHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwsIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFuZ3VsYXIubW9kdWxlKCdibHVlc2t5Lmh0dHBXcmFwcGVyJywgWyd0b2FzdGVyJywgJ25nQW5pbWF0ZScsICduZ0ZpbGVVcGxvYWQnXSlcclxuICAgICAgICAuY29uc3RhbnQ8VW5kZXJzY29yZVN0YXRpYz4oJ18nLCB3aW5kb3cuXylcclxuICAgICAgICAuY29uc3RhbnQ8bW9tZW50Lk1vbWVudFN0YXRpYz4oJ21vbWVudCcsIHdpbmRvdy5tb21lbnQpXHJcbiAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2VzIHtcclxuXHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuSVVzZXJSb2xlRW50cnlEdG87XHJcbiAgICBpbXBvcnQgVXNlclNzb0R0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuSVVzZXJTc29EdG87XHJcbiAgICBpbXBvcnQgQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnID0gYmx1ZXNreS5jb3JlLm1vZGVscy5ibHVlc2t5SHR0cENsaWVudC5JQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnO1xyXG4gICAgaW1wb3J0IEZpbGVDb250ZW50ID0gYmx1ZXNreS5jb3JlLm1vZGVscy5ibHVlc2t5SHR0cENsaWVudC5GaWxlQ29udGVudDtcclxuICAgIGltcG9ydCBCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8gPSBibHVlc2t5LmNvcmUubW9kZWxzLmNsaWVudENvbmZpZy5JQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG4gICAgaW1wb3J0IEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWxzLmNsaWVudENvbmZpZy5FbmRwb2ludFR5cGVFbnVtO1xyXG5cclxuICAgIGVudW0gSHR0cE1ldGhvZCB7IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE8gTUdBIGNvbW1lbnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJQmx1ZXNreUh0dHBXcmFwcGVyIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIHNydi1zaWRlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBodHRwIGNsaWVudCwgcHJvdmlkZWQgYnkgdGhlIGluamVjdGVkICdjb25maWdJbml0aWFsaXphdGlvblVSTCcgZW5kcG9pbnQuXHJcbiAgICAgICAgICogVGhpcyBjb25maWd1cmF0aW9uIGRhdGEgaXMgbG9hZGVkIHVwb24gaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBzZXJ2aWNlICh0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uIGluIHRoZSBhcHApLiBBbGwgb3RoZXIgd2ViIGNhbGxzIGFyZSBibG9ja2VkIGFzIGxvbmcgYXMgdGhpcyBvbmUgaXMgbm90IGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJsdWVza3lBamF4Q2xpZW50Q29uZmlnOiBCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG87XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+O1xyXG5cclxuICAgICAgICBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlciBpbXBsZW1lbnRzIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwcml2YXRlIGdldENvbmZpZ1Byb21pc2U6IG5nLklQcm9taXNlPGFueT47XHJcblxyXG4gICAgICAgIHB1YmxpYyBibHVlc2t5QWpheENsaWVudENvbmZpZzogQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIGN0b3JcclxuXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHByaXZhdGUgXzogVW5kZXJzY29yZVN0YXRpYyxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkaHR0cDogbmcuSUh0dHBTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRxOiBuZy5JUVNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgdG9hc3Rlcjogbmd0b2FzdGVyLklUb2FzdGVyU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBjb25maWdJbml0aWFsaXphdGlvblVSTDogc3RyaW5nLFxyXG4gICAgICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG9cclxuICAgICAgICApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBmZXRjaCB0aGUgY29uZmlndXJhdGlvbiBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBzZXJ2aWNlIHRvIHJ1biBmcm9tIHRoZSBwcm92aWRlZCBlbmRwb2ludFxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbkVuZHBvaW50VXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnJHtjb25maWdJbml0aWFsaXphdGlvblVSTH0nIHdpdGggZW5kcG9pbnRUeXBlICcke0VuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXX0nLiBBYm9ydGluZyBibHVlc2t5SHR0cFNlcnZpY2UgaW5pdC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogY3VzdG9tIGNvbmZpZyBmb3IgaGVhZGVycyBoYXJkIGNvZGVkLCB0byBtdXR1YWxpemUgd2l0aCBjb25zdFxyXG4gICAgICAgICAgICB0aGlzLmdldENvbmZpZ1Byb21pc2UgPSB0aGlzLiRodHRwLmdldDxCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8+KGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCwgeyBoZWFkZXJzOiB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9fSlcclxuICAgICAgICAgICAgICAgIC50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oXHJcbiAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAoY2xpZW50Q29uZmlnUHJvbWlzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGllbnRDb25maWdQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBVbmFibGUgdG8gcmV0cmlldmUgaHR0cCBjb25maWcgZGF0YSBmcm9tICcke2NvbmZpZ0luaXRpYWxpemF0aW9uVVJMfScuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRvYXN0ZXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgPSBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBlcnJvclxyXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4gU3J2IG1zZzogJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNob3cgdG9hc3RlciA/IGJhc2VkIG9uIHByb3ZpZGVyIGNvbmZpZyBmbGFnID9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oXHJcbiAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICAoYmx1ZXNreUNsaWVudENvbmZpZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBjYXNlIHdoZXJlIGNsaWVudC1zaWRlIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBhbmQgbm90ID09IHNydi1zaWRlIHVzZXIgcm9sZSAhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIG5vdCBwcm92aWRlZCBieSBkb21haW4gZnJvbSB3aGljaCBjb2RlIHdhcyBsb2FkZWQsIHRoZW4gdHJ5IHRvIGZldGNoIGRlZmF1bHQgdXNlclJvbGUgZnJvbSBDQVBJIGVuZHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldDxVc2VyU3NvRHRvPigndXNlci1zc28/cHJvZmlsZT0nLCB7IGVuZHBvaW50VHlwZTogRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpIH0pLnRoZW48Qmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1c2VyU3NvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyU3NvIHx8ICF1c2VyU3NvLlVzZXJSb2xlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmFibGUgdG8gcmV0cmlldmUgQ29yZUFQSSBkZWZhdWx0IHVzZXJTU08uIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgc2VsZWN0ZWRVc2VyUm9sZSBpcyBhdmFpbGFibGUgaW4gdGhlIGxpc3Qgb2YgdXNlclNTTyByb2xlcywgb3RoZXJ3aXNlIHNlbGVjdCBkZWZhdWx0ICFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaW5mb3JtIGJhY2sgdGhlIERBIHRoYXQgc2VsZWN0ZWRVc2VyUm9sZSB3YXMgcmVzZXQgPyBpbnZlcnQgcmVzcG9uc2FiaWxpdHkgJiBzdG9yZSB1c2VyUm9sZSBpbiBsb2NhbFN0b3JhZ2UgZnJvbSB0aGlzIHNlcnZpY2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUm9sZVRvVXNlID0gc2VsZWN0ZWRVc2VyUm9sZSB8fCB1c2VyU3NvLlVzZXJSb2xlRW50cnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRoaXMgbmVlZHMgdG8gYmUgcHV0IGluIHNoYXJlZCBleHRlbnNpb24gbWV0aG9kIC8gc2VydmljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlID0gdXNlclJvbGVUb1VzZS5OYW1lICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLlJvbGUgKyBcIiBcIiArIHVzZXJSb2xlVG9Vc2UuU2lsbztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlciA9IHVzZXJTc287XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHVlc2t5Q2xpZW50Q29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHdlIG9ubHkgbG9hZCB1c2VyU1NPIGlmIG5vIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBzcnYtc2lkZSwgc2hvdWxkIHdlIGxvYWQgaXQgaW4gYWxsIGNhc2VzID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZGVmaW5lZCB1c2VyUm9sZSBzZW50IGZyb20gb3JpZ2luIGFwcCwgdXNlIGl0ICYgc2V0IGl0IGFzIGRlZmF1bHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHVlc2t5Q2xpZW50Q29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcclxuXHJcbiAgICAgICAgZ2V0PFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3N0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xyXG4gICAgICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAgICAgKiBAcGFyYW0gZmlsZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVwbG9hZEluQmFzZTY0SnNvbikge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHRoaXMgZGVsYXlzIG5leHQgY2FsbCBhbmQgdXBsb2FkIGlzIG5vdCBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgaXMgZmluaXNoZWQsIGV2ZW4gaWYgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkID8/P1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLmJhc2U2NERhdGFVcmwoZmlsZSkudGhlbigoZmlsZUJhc2U2NFVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQtY29kZWQga2V5IHRvIGZldGNoIGJhc2U2NCBlbmNvZGluZywgdG8gcGFyYW1ldHJpemUgd2l0aCBzZXJ2ZXItc2lkZSAhXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUJhc2U2NFVybCA9IGZpbGVCYXNlNjRVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWwgcG9zdCBpbiBjYXNlIG9mIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgPyAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Q29uZmlnKSAvLyBpZiBubyBjb25maWcgcmV0dXJuZWQsIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBkbyBub3Qgc3RhcnQgYWpheCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC51cGxvYWQ8VD4oPG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklGaWxlVXBsb2FkQ29uZmlnRmlsZT5yZXF1ZXN0Q29uZmlnKSAvL1RPRE8gTUdBIDogbm90IHNhZmUgaGFyZCBjYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzczxUPihjb25maWcpLCB0aGlzLm9uRXJyb3I8VD4oY29uZmlnKSwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vVE9ETyBNR0E6IHdoYXQgdG8gcmV0dXJuID9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRvd25sb2FkIGEgZmlsZSBpbiB0aGUgZm9ybSBvZiBhIGJ5dGUtc3RyZWFtIGZyb20gYW4gZW5kcG9pbnQgYW5kIHdyYXAgaXQgaW50byBhIEZpbGVDb250ZW50IG9iamVjdCB3aXRoIG5hbWUsIHR5cGUgJiBzaXplIHByb3BlcnRpZXMgcmVhZCBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIHNlcnZldXIuXHJcbiAgICAgICAgICogSXQgaXMgdGhlIHJlc3BvbnNhYmlsaXR5IG9mIHRoZSBjb25zdW1lciB0byBkbyBzb21ldGhpbmcgd2l0aCB0aGUgd3JhcHBlZCBieXRlQXJyYXkgKGZvciBleGFtcGxlIGRvd25sb2FkIHRoZSBmaWxlLCBvciBzaG93IGl0IGluc2lkZSB0aGUgd2ViUGFnZSBldGMpLlxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xyXG4gICAgICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWROYW1lXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkU2l6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGVcclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFySHR0cENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdCgnVW5hYmxlIHRvIGNvbmZpZ3VyZSByZXF1ZXN0IGNvcnJlY3RseS4gQWJvcnRpbmcgZ2V0RmlsZSBhamF4IGNhbGwuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxyXG4gICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHJcbiAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8QXJyYXlCdWZmZXI+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuPEZpbGVDb250ZW50PigoaHR0cFJlc3BvbnNlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLm9uU3VjY2VzczxBcnJheUJ1ZmZlcj4oY29uZmlnKShodHRwUmVzcG9uc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcHJvbWlzZSByZWplY3Rpb24gdnMuIHJldHVybiBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcikgcmV0dXJuIG51bGw7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlYWQgZmlsZSBpbmZvIGZyb20gcmVzcG9uc2UtaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQ6IEZpbGVDb250ZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE51bWJlcihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1sZW5ndGgnKSkgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LXR5cGUnKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub25FcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxyXG4gICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKSBcclxuICAgICAgICAgKiBPdGhlcndpc2UsIHRyaWVzIHRvIGZpbmQgdGhlIGJhc2UgVVJMIG9mIHRoZSBjdXJyZW50IEJsdWVTa3kgYXBwIHdpdGggb3Igd2l0aG91dCB0aGUgaW5jbHVkZWQgQ29udHJvbGxlciBhbmQgcmV0dXJucyB0aGUgZnVsbCBVcmwgXHJcbiAgICAgICAgICogQHBhcmFtIHVybElucHV0IDogVE9ETyBNR0E6IGRvY3VtZW50IGRpZmZlcmVudCBraW5kIG9mIHVybHMgdGhhdCB0aGlzIG1ldGhvZCBjYW4gdGFrZSBhcyBpbnB1dCAoZnVsbCwgcGFydGlhbCBldGMpXHJcbiAgICAgICAgICogQHJldHVybiBudWxsIGlmIG5vdCBhYmxlIHRvIGNvbXB1dGUgdXJsLiBPdGhlcndpc2UsIHVybCBvZiB0aGUgcmVxdWVzdCBlaXRoZXIgcGFydGlhbCBvciBmdWxsIGJhc2VkIG9uIGVuZHBvaW50VHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nLCBlbmRwb2ludFR5cGU/OiBFbmRwb2ludFR5cGVFbnVtKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghdXJsSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignTm8gVVJMIGlucHV0IHByb3ZpZGVkLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIFVybCBzdGFydHMgd2l0aCBodHRwOi8vIG9yIGh0dHBzOi8vID0+IHJldHVybiBhcyBpcywgZXZlbiBpZiBlbmRwb2ludFR5cGUgaXMgbm90IGV4dGVybmFsLlxyXG4gICAgICAgICAgICBpZiAodXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHA6Ly8nLmxlbmd0aCkgPT09ICdodHRwOi8vJyB8fFxyXG4gICAgICAgICAgICAgICAgdXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHBzOi8vJy5sZW5ndGgpID09PSAnaHR0cHM6Ly8nKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignRnVsbCBVUkwgcHJvdmlkZWQgZm9yIGEgY2FsbCB0aGF0IGlzIG5vdCBmbGFnZ2VkIGFzIFxcJ0V4dGVybmFsXFwnIGVuZHBvaW50VHlwZSwgdGhpcyBpcyBiYWQgcHJhY3RpY2UgYXMgb25seSB0aGUgYmx1ZXNreVdyYXBwZXIgc2hvdWxkIGtub3cgYWJvdXQgdGhlIGJhc2VVUkwgb2YgdGFyZ2V0IGVuZHBvaW50cyAobG9hZGVkIGZyb20gc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52KS4gVXNlIHBhcnRpYWwgVVJMcy4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVsc2UsIHdlIGhhdmUgYSBwYXJ0aWFsIFVSTCB0byBjb21wbGV0ZTogdXNlIHByb3ZpZGVkIGVuZHBvaW50IHR5cGUgdG8gZGV0ZXJtaW5lIGhvdyB0byBjb21wbGV0ZSB1cmwuXHJcblxyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciBlbmRwb2ludFR5cGUgaWYgbm90IHByb3ZpZGVkIGlzIG9yaWdpbi4gVE9ETyBNR0E6IHJ1bGUgdG8gZGlzY3VzcywgaGVyZSBmb3IgcmV0cm8tY29tcGF0aWJpbGl0eS5cclxuICAgICAgICAgICAgZW5kcG9pbnRUeXBlID0gZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsOiBzdHJpbmc7XHJcblxyXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignUGFydGlhbCB1cmwgcHJvdmlkZWQgZm9yIGEgY2FsbCB3aXRoIGVuZHBvaW50VHlwZSBmbGFnZ2VkIGFzIFxcJ0V4dGVybmFsXFwnOiB0aGUgY2FsbCB3aWxsIHByb2JhYmx5IGZhaWwuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IG1vZGlmeSBwcm92aWRlZCB1cmwgaWYgZXh0ZXJuYWwgKHdlIGNhbm5vdCBrbm93IGhvdyB0byBjb21wbGV0ZSBpdCwgZXZlbiBpZiBwYXJ0aWFsKS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWdleCB0cnlpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbnB1dCBmcmFnbWVudCBjb250YWlucyBhIC8gYmV0d2VlbiB0d28gY2hhcmFjdGVyIHN1aXRlcyA9PiBjb250cm9sbGVyIGdpdmVuIGFzIGlucHV0LCBvdGhlcndpc2UsIGFjdGlvbiBvbiBzYW1lIGNvbnRyb2xsZXIgZXhwZWN0ZWRcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVySXNQcmVzZW50UmVnZXggPSAvXFx3K1xcL1xcdysvO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgZW5kcG9pbnRUeXBlczogY29tcHV0ZSBVUkwgYXMgYSBjb21iaW5hdGlvbiBvZiBiYXNlVVJMICYgc3VmZml4IGlmIHByZXNlbnQsIGFzIHByb3ZpZGVkIGJ5IHNlcnZlci1jb25maWd1cmF0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdFeHBlY3RlZCBlbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSBwcm92aWRlZCBidXQgbm9uZSBmb3VuZC4gQWJvcnRpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgSEFDS1k6IHNlYXJjaCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW5kcG9pbnQgdHlwZSBpbiBkaWN0IGR1ZSB0byBzZXJpYWxpemF0aW9uIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50Q29uZmlnID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtFbmRwb2ludFR5cGVFbnVtW2VuZHBvaW50VHlwZV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZW5kcG9pbnRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYEVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2VuZHBvaW50VHlwZV19JyBpcyBub3QgJ0V4dGVybmFsJyBvciAnQ3VycmVudERvbWFpbicsIGV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnRDb25maWd1cmF0aW9uIHByb3ZpZGVkIGluIGJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5IGJ1dCBub25lIGZvdW5kLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gZW5kcG9pbnRDb25maWcuRW5kcG9pbnRCYXNlVVJMICsgKGVuZHBvaW50Q29uZmlnLkVuZHBvaW50U3VmZml4IHx8ICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGhhbmRsZSBPTSBhcHBzIGV4dGVybmFsIGNhbGxzIHdpdGhvdXQgc2Vzc2lvbiBwcm92aWRlZCA/IHdpbGwgcmVzdWx0IGluIGEgcmVkaXJlY3QgYW5kIGNhbGwgbWF5IGZhaWwgP1xyXG5cclxuICAgICAgICAgICAgLy8gQm9vbGVhbiB1c2VkIHRvIHRyeSB0byBkZXRlcm1pbmUgY29ycmVjdCBmdWxsIHVybCAoYWRkIC8gb3Igbm90IGJlZm9yZSB0aGUgdXJsIGZyYWdtZW50IGRlcGVuZGluZyBvbiBpZiBmb3VuZCBvciBub3QpXHJcbiAgICAgICAgICAgIHZhciB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA9IHVybElucHV0LnNsaWNlKDAsIDEpID09PSAnLyc7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoID0gYmFzZVVybC5zbGljZShiYXNlVXJsLmxlbmd0aCAtIDEsIGJhc2VVcmwubGVuZ3RoKSA9PT0gJy8nO1xyXG5cclxuICAgICAgICAgICAgLy9iYXNlZCBvbiBzdGFydGluZy90cmFpbGluZyBzbGFzaGVzLCByZXR1cm4gZnVsbCB1cmwuXHJcbiAgICAgICAgICAgIGlmIChiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKVxyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxhc3QgJy8nIG9uIGJhc2VVcmxcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsLnNsaWNlKDAsIGJhc2VVcmwubGVuZ3RoIC0gMSkgKyB1cmxJbnB1dDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgIXVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyAnLycgKyB1cmxJbnB1dDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgIXVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgdXJsSW5wdXQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kLlxyXG4gICAgICAgICAqIE1haW4gY2FsbGVyIHRoYXQgYWxsIHdyYXBwZXIgY2FsbHMgKGdldCwgZGVsZXRlLCBwb3N0LCBwdXQpIG11c3QgdXNlIHRvIHNoYXJlIGNvbW1vbiBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBhamF4PFQ+KG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ha2Ugc3VyZSBnZXRDb25maWcgcmVzb2x2ZSBhdXRvbWF0aWNhbGx5IHdpdGhvdXQgb3ZlcmhlYWQgb25jZSBmaXJzdCBjYWxsIHN1Y2Vzc2Z1bGwuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJIChpbml0Q2FsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXJIdHRwQ29uZmlnKSAvLyBpZiBubyBjb25maWcgcmV0dXJuZWQsIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBkbyBub3Qgc3RhcnQgYWpheCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8VD4oYW5ndWxhckh0dHBDb25maWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuPFQ+KHRoaXMub25TdWNjZXNzPFQ+KGNvbmZpZyksIHRoaXMub25FcnJvcjxUPihjb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogUHJlcGFyZXMgYSB7QGxpbmsgbmcjJGh0dHAjY29uZmlnIGNvbmZpZ30gb2JqZWN0IGZvciAkaHR0cCBjYWxsLlxyXG4gICAgICAgICogVGhlIG9wZXJhdGlvbnMgaW5jbHVkZSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIHdoZW4gbm90IHByb3ZpZGVkLCBhbmQgc2V0dGluZyBodHRwIGhlYWRlcnMgaWYgbmVlZGVkIGZvciA6XHJcbiAgICAgICAgKiAgLSBBamF4IGNhbGxzXHJcbiAgICAgICAgKiAgLSBBdXRob3JpemF0aW9uIHRva2VuXHJcbiAgICAgICAgKiAgLSBDdXJyZW50IFVzZXJSb2xlLiAgIFxyXG4gICAgICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAgICAqIEByZXR1cm5zIHtuZy4kaHR0cC5jb25maWd9IHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCByZWFkeSB0byBiZSBpbmplY3RlZCBpbnRvIGEgJGh0dHAgY2FsbC4gXHJcbiAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIGNvbmZpZ3VyZUh0dHBDYWxsID0gKG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklSZXF1ZXN0Q29uZmlnID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIGlucHV0IHZhbGlkYXRpb25cclxuXHJcbiAgICAgICAgICAgIGlmICghdXJsIHx8IG1ldGhvZCA9PT0gbnVsbCB8fCBtZXRob2QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVUkwgJiBNRVRIT0QgcGFyYW1ldGVycyBhcmUgbmVjZXNzYXJ5IGZvciBodHRwV3JhcHBlciBjYWxscy4gQWJvcnRpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgY29uZmlnIHZhbHVlcyBhbmQgY3VzdG9tIG9uZXMgYmFzZWQgb24gZW5kcG9pbnRzXHJcblxyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID0gY29uZmlnLmVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47IC8vIGRlZmF1bHQgdmFsdWU6IGlmIG5vdCBzcGVjaWZpZWQsIGVuZHBvaW50IHRvIHVzZSBpcyBzdXBwb3NlZCB0byBiZSB0aGUgb3JpZ2luLlxyXG5cclxuICAgICAgICAgICAgLy8gc2VhcmNoIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbmRwb2ludCB0eXBlXHJcbiAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYWtlIHN1cmUgRW5kcG9pbnRUeXBlRW51bVtpbnZhbGlkIHZhbHVlXSBkb2Vzbid0IHJldHVybiBkZWZhdWx0IHZhbGlkIGVudW0gdmFsdWUgPz8/IG90aGVyd2lzZSwgZGFuZ2Vyb3VzICFcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFbmRwb2ludENvbmZpZyA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgJiYgdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdXTtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxyXG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSA8bmcuSVJlcXVlc3RDb25maWc+Y29uZmlnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XHJcblxyXG4gICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBkZWZhdWx0IGNvbmZpZyBmbGFncyBiYXNlZCBvbiB0YXJnZXQgZW5kcG9pbnRcclxuICAgICAgICAgICAgc3dpdGNoIChjb25maWcuZW5kcG9pbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NYXJrZXRpbmdBcGk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2VsZmNhcmVBcGk6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGxpY2l0bHkgd3JvbmcgaW5wdXQgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBBUEkgY2FsbCBpbnRlbmRlZCB3aXRoIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEFib3J0aW5nIGFqYXggY2FsbC5gLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMgZm9yIEFQSSBlbmRwb2ludHMgYXJlIGRpZmZlcmVudCBmcm9tIGRlZmF1bHQsIHNvIHdlIG11c3Qgc3BlY2lmeSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTsgLy8gYnkgZGVmYXVsdCBhbHJlYWR5IGVuYWJsZWQsIGJ1dCBlbmZvcmUgdGhpcyBoZWFkZXIgYXMgbmVjZXNzYXJ5IGZvciBjYWxscyB0byBXZWJBUEkgZW5kcG9pbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlOyAvLyBmb3IgYXBpIGNhbGxzLCBmb3JjZSB0aGlzIHJvbGUgdG8gYmUgcGFzc2VkIGFyb3VuZCAoc2hvdWxkIGJlIG1hbmRhdG9yeSB0byBjb250ZXh0dWFsaXplIHJlcXVlc3QgdG8gcmVhbG0gb2YgY3VycmVudCB1c2VyKS5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5RdW90ZVdpemFyZDpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5PcmRlckVudHJ5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyVHJhY2tpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIE9NIGFwcHMgY2FsbGVkIGFzIGVuZHBvaW50cywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogYWRkIGN1cnJlbnRVc2VyUm9sZSBieSBkZWZhdWx0IHNvIHRoYXQgT00gYXBwcyBjYW4gY29udGV4dHVhbGlzZSB0aGUgcmVxdWVzdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWV0cmFuZXQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVjaG5pY2FsSW52ZW50b3J5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlRlbXBsYXRlR2VuZXJhdG9yOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlNhbGVzZm9yY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm8gc3BlY2lmaWMgY29uZmlnIGZvciB0aG9zZSBleHRlcm5hbCBlbmRwb2ludHMgPyBhZGQgY3VzdG9tIG9uZXMgaWYgbmVlZGVkIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWpheCBjYWxscywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWw6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSB0byBjb25maXJtXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IHRydWU7IC8vIGRvIG5vdCBhZGQgWG1sSHR0cFJlcXVlc3QgaWYgZXh0ZXJuYWwgVXJsIGJ5IGRlZmF1bHQ6IG1pZ2h0IGNyZWF0ZSBjb25mbGljdHMgb24gY2VydGFpbiBzZXJ2ZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXVske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBVbnN1cHBvcnRlZCBlbmRwb2ludFR5cGUgcHJvdmlkZWQ6ICcke0VuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV19Jy4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9icmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9SZWplY3QgYWpheCBjYWxscyBpbnRlbmRlZCB0byBleHRlcm5hbCBlbmRwb2ludHMgd2l0aG91dCBuZWNlc3NhcnkgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluICYmXHJcbiAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlICE9PSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsICYmXHJcbiAgICAgICAgICAgICAgICAhY3VycmVudEVuZHBvaW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbJHtjb25maWdGdWxsLm1ldGhvZH0gLyAke3VybH1dIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgZXhwZWN0ZWQgZW5kcG9pbnQgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyIGZvciBlbmRwb2ludFR5cGUgJyR7RW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXX0nLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXHJcbiAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGJ1aWxkIGEgdmFsaWQgdXJsIGZyb20gaW5wdXQgJiBlbmRwb2ludFR5cGUuXHJcbiAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgY29uZmlnLmVuZHBvaW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ0Z1bGwudXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSB1cmxJbnB1dCAnJHt1cmx9JyB3aXRoIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdfScuIEFib3J0aW5nIGFqYXggY2FsbC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gWyR7Y29uZmlnRnVsbC5tZXRob2R9IC8gJHt1cmx9XSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSB1c2VyUm9sZSBzZXQgaW4gY29uZmlnLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydPQS1Vc2VyUm9sZSddID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgYXV0aCB0b2tlbiBwcm92aWRlZCBmb3IgdGFyZ2V0IGVuZHBvaW50LCBhZGQgaXQgaW4gaGVhZGVyXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RW5kcG9pbnRDb25maWcuQXV0aFRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGF1dGhUb2tlbiBmb3IgZW5kcG9pbnRzIHRoYXQgYXJlIG5vdCAnc2FmZScgdG8gc2hhcmUgYXV0aCB0b2tlbiB3aXRoLCBzdWNoIGFzIEV4dGVybmFsIG9uZXMgPyBPciBhdXRob3JpemUgdGhpcyBzbyB0aGF0IHNlcnZlciBjYW4gbG9hZCBhbiBhdXRoIHRva2VuIGZvciBjZXJ0YWluIGV4dGVybmFsIGVuZHBvaW50cyA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHRva2VuIHZhbGlkaXR5IGVuZERhdGU6IHJlbmV3IGF1dGggYmVmb3JlIHRoZSBjYWxsICEgV2hhdCdzIHRoZSBiZXN0IG1vbWVudCB0byBkbyBpdCA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIGN1cnJlbnRFbmRwb2ludENvbmZpZy5BdXRoVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZSwgb3IgYXQgbGVhc3QgcHV0IGluIGFzIGNvbmZpZyBwYXJhbVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWNjZXNzIGhhbmRsZXIuXHJcbiAgICAgICAgICogQ2FwdHVyZXMgdGhlIGlucHV0IHBhcmFtZXRlcnMgYXQgdGhlIG1vbWVudCBvZiBpdHMgZGVjbGFyYXRpb24gJiByZXR1cm4gdGhlIHJlYWwgaGFuZGxlciB0byBiZSBjYWxsZWQgdXBvbiBwcm9taXNlIGNvbXBsZXRpb24uXHJcbiAgICAgICAgICogSW5wdXQgcGFyYW1ldGVyczpcclxuICAgICAgICAgKiAgLSBjYWxsaW5nQ29uZmlnOiBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWFrZSB0aGUgYWpheCBjYWxsLCBpbiBjYXNlIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIG51bGwvZW1wdHkgYW5kIGRvZXNuJ3QgY29udGFpbiBuZWNlc3NhcnkgZGF0YSBmb3IgZGVidWdnaW5nLlxyXG4gICAgICAgICAqICAtIGdldENvbXBsZXRlUmVzcG9uc2VPYmplY3Q6IGZsYWcgaW5kaWNhdGlvbiBpZiB3ZSBtdXN0IHJldHVybiB0aGUgZnVsbCByZXNwb25zZSBvYmplY3QgYWxvbmcgd2l0aCBoZWFkZXJzIGFuZCBzdGF0dXMgb3Igb25seSB0aGUgaW5uZXIgZGF0YS4gQnkgZGVmYXVsdCAmIGlmIG5vdCBzcGVjaWZpZWQsIG9ubHkgcmV0dXJucyBpbm5lciBkYXRhLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgb25TdWNjZXNzID0gPFQ+KG9yaWdpbmFsQ29uZmlnOiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiAoaHR0cFByb21pc2U6IG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPFQ+KSA9PiBUID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIDxUPihodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pOiBUID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtIVFRQIG5vLXJlc3BvbnNlXSBVbmV4cGVjdGVkICRodHRwIGVycm9yLCBubyByZXNwb25zZSBwcm9taXNlIHJldHVybmVkLmApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsQ29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdVbmV4cGVjdGVkIGJlaGF2aW9yJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgbXVsdGktdHlwZSByZXR1cm4gaW4gY2FzZSBvZiByZWplY3Rpb24gb3IgZG8gc29tZXRoaW5nIGVsc2UgPyB0aGlzIG1ldGhvZCBpcyBjdXJyZW50bHkgdXNlZCBzeW5jaHJvbm91c2x5IHdpdGhvdXQgcHJvbWlzZSB3YWl0aW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTsgLy8gUmVqZWN0IHByb21pc2VcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3QgaWYgc3RhdHVzICE9IDJYWCA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHdoZW4gQVBJIGlzIGZpeGVkLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTc0Njg5NC93aGF0LWlzLXRoZS1wcm9wZXItcmVzdC1yZXNwb25zZS1jb2RlLWZvci1hLXZhbGlkLXJlcXVlc3QtYnV0LWFuLWVtcHR5LWRhdGFcclxuICAgICAgICAgICAgICAgIC8vaWYgKChwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gbnVsbCB8fCBwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gdW5kZWZpbmVkKSAmJiBwcm9taXNlQ2FsbGJhY2suc3RhdHVzICE9PSAyMDQpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMuJGxvZy5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgYnV0IG5vbmUgZm91bmQuJyk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnVW5leHBlY3RlZCByZXNwb25zZScsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcclxuICAgICAgICAgICAgICAgIC8vICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChwcm9taXNlQ2FsbGJhY2spOyAvLyBSZWplY3QgcHJvbWlzZSBpZiBub3Qgd2VsbC1mb3JtZWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzYW1lIGJlaGF2aW9yIGFsc28gb24gYSBHRVQgcmVxdWVzdCA/IGlmIHJlcXVlc3QgaXMgR0VUIGFuZCByZXNwb25zZSBpcyAyMDAgd2l0aCBubyBkYXRhLCByZXR1cm4gZXJyb3IgPyAocGFzcyBpbiBwYXJhbWV0ZXIgcmVxdWVzdCBjb250ZXh0IHRvIGxvZyB0aGlzIGVycm9yKS5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmRlYnVnKGBbSFRUUCAke2h0dHBQcm9taXNlLmNvbmZpZy5tZXRob2R9XSBbJHtodHRwUHJvbWlzZS5jb25maWcudXJsfV1gLCBodHRwUHJvbWlzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9ubHkgdGhlIGRhdGEgZXhwZWN0ZWQgZm9yIGNhbGxlclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXJyb3IgaGFuZGxlclxyXG4gICAgICAgICAqIFRPRE8gTUdBOiBhbmd1bGFyIHNpZ25hdHVyZXMgaW5kaWNhdGVzIHRoYXQgcGFyYW1ldGVyIGlzIHJlamVjdGlvbiByZWFzb24sIG5vdCBuZWNlc3NhcmlseSBodHRwUHJvbWlzZTogaW52ZXN0aWdhdGUgJiBmaXggaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICogQHBhcmFtIGh0dHBQcm9taXNlIFxyXG4gICAgICAgICAqIEByZXR1cm5zIHt9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgb25FcnJvciA9IDxUPihvcmlnaW5hbENvbmZpZzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogKGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxhbnk+KSA9PiBhbnkgPT4ge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDxUPihodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55Pik6IGFueSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYXkgYWxzbyBiZSBhIGZhdWx0IGluIGludGVybmFsICRodHRwIC8gYWpheCBjbGllbnQgc2lkZSBsaWIsIHRvIGRpc3Rpbmd1aXNoLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSB8fCAhaHR0cFByb21pc2UuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcclxuICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5zdGF0dXMgPSA1MDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGNvbnRlbnRUeXBlIHRvIHRyeSB0byBkaXNwbGF5IGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2U6IHN0cmluZyA9IFwiXCI7IC8vZGVmYXVsdCBtZXNzYWdlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgZXJyb3IgaGFuZGxpbmcgbW9yZSBnZW5lcmljYWxseSBiYXNlZCBvbiBpbnB1dCBlcnJvciBtZXNzYWdlIGNvbnRyYWN0IGluc3RlYWQgb2YgZXhwZWN0aW5nIHNwZWNpZmljIGVycm9yIHN0cmN0dXJlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC8vVE9ETyBNR0EgOiBoYW5kbGUgdGhpcyB3aGVuIHdlbGwgZm9ybWF0dGVkIHNlcnZlci1zaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgbW9yZSByZXNwb25zZSBjb2RlcyBncmFjZWZ1bGx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdOb3QgRm91bmQnLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlY292ZXIgZnJvbSBlcnJvciwgc28gd2UgcHJvcGFnYXRlIGl0IDogYmVsb3cgaGFuZGxlcnMgaGF2ZSB0aGUgY2hvaWNlIG9mIHJlYWRpbmcgdGhlIGVycm9yIHdpdGggYW4gZXJyb3IgaGFuZGxlciBvciBub3QuIFNlZSAkcSBwcm9taXNlcyBiZWhhdmlvciBoZXJlIDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGRlc2lyZWQgc28gdGhhdCB3ZSBzaG93IGVycm9yIGluc2lkZSBzcGVjaWZpYyBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBtb2RhbHMgYXQgc3BlY2lmaWMgcGxhY2VzIGluIHRoZSBhcHAsIG90aGVyd2lzZSBzaG93IGEgZ2xvYmFsIGFsZXJ0IG1lc3NhZ2UsIG9yIGV2ZW4gZG8gbm90IHNob3cgYW55dGhpbmcgaWYgbm90IG5lY2Vzc2FyeSAoZG8gbm90IGFkIGFuIGVycm9yIGhhbmRsZXIgaW4gYmVsb3cgaGFuZGxlcnMgb2YgdGhpcyBwcm9taXNlKS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFqYXggY2FsbCwgcmVnYXJkbGVzcyBvZiBpdCdzIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cclxuICAgICAgICAgKiBAcGFyYW0gcmVzcG9uc2VcclxuICAgICAgICAgKiBUT0RPIE1HQSBpbnZlcnNpb24gb2YgcmVzcG9uc2FiaWxpdHk6IG1ha2UgdGhpcyBleHRlbnNpYmxlIHNvIHRoYXQgc3BlY2lmYyBhcHBzIGNhbiBwbHVnIGludG8gdGhpcyBldmVudCB3b3JrZmxvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgZmluYWxseSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Utc3BlY2lmaWMgY29kZVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxyXG4gICAgICAgIC8vVE9ETyBNR0E6IHVucm9idXN0LCBuZWVkcyBzb2xpZCByZWZhY3RvIHRvIG1ha2UgaXQgbW9yZSBnZW5lcmljIHdoZW4gb24gb3JpZ2luIGRvbWFpbiAhXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcjogYm9vbGVhbik6IHN0cmluZyB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc1JlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ky87XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsQXNwQXBwc1JlZ2V4ID0gLyhcXC9cXHcrKVxcL1xcdysvO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuJHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNNYXRjaGVzID0gYmFzZVVybE9tQXBwc1JlZ2V4LmV4ZWModXJsKTtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyA9IGJhc2VVcmxBc3BBcHBzUmVnZXguZXhlYyh1cmwpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gMiBtYXRjaGVzID0gcmVnZXggbWF0Y2hlcyArIHRoZSBjYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICAgICAgaWYgKGJhc2VVcmxPbUFwcHNNYXRjaGVzICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsT21BcHBzTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybE9tQXBwc01hdGNoZXNbMF07XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybE9tQXBwc01hdGNoZXNbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q3VycmVudFNlc3Npb25JRCgpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxyXG4gICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oY29udGVudERpc3Bvc2l0aW9uSGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyLnNwbGl0KCc7JylbMV0udHJpbSgpLnNwbGl0KCc9JylbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiXG5cblxuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZXM7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZXMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvdmlkZXIgZm9yIHRoZSBCbHVlc2t5SHR0cFdyYXBwZXIuXG4gICAgICAgICAgICAgKiBFbmFibGVzIHBlci1jb25zdW1lciBjb25maWd1cmF0aW9uIG9mIHRoZSBodHRwIHNlcnZpY2UgdG8gc2V0IGN1c3RvbSBjb25maWd1cmF0aW9uIFVSTCB0byBmZXRjaCBkYXRhIGZyb206XG4gICAgICAgICAgICAgKiAgLSBDbGllbnQgaW5pdGlhbCBjb25maWd1cmF0aW9uIFVSTCBmcm9tIHRoZSBvcmlnaW4gdGhlIGFwcCB3YXMgbG9hZGVkIGZyb20uXG4gICAgICAgICAgICAgKiAgLSBVc2VyUm9sZSB0byB1c2Ugb2YgYWxyZWFkeSBmZXRjaGVkIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsID0gJ0JsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbi9HZXRBamF4Q2xpZW50Q29uZmlndXJhdGlvbic7IC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSA9IG51bGw7IC8vIGJ5IGRlZmF1bHQgbm90LXNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGVyJ3MgZmFjdG9yeSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvKiBAbmdJbmplY3QgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24gKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIsIF90aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsLCBfdGhpcy5zZWxlY3RlZFVzZXJSb2xlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBjb25maWd1cmF0aW9uIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlci5wcm90b3R5cGUuc2V0Q2xpZW50Q29uZmlnVVJMID0gZnVuY3Rpb24gKGNsaWVudENvbmZpZ1VybFRvVXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwgPSBjbGllbnRDb25maWdVcmxUb1VzZSB8fCB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIucHJvdG90eXBlLnNldFVzZXJSb2xlVG9Vc2UgPSBmdW5jdGlvbiAodXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gdXNlclJvbGUgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBzZXJ2aWNlcy5CbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyO1xuICAgICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ2JsdWVza3kuaHR0cFdyYXBwZXInLCBbJ3RvYXN0ZXInLCAnbmdBbmltYXRlJywgJ25nRmlsZVVwbG9hZCddKVxuICAgICAgICAgICAgICAgIC5jb25zdGFudCgnXycsIHdpbmRvdy5fKVxuICAgICAgICAgICAgICAgIC5jb25zdGFudCgnbW9tZW50Jywgd2luZG93Lm1vbWVudClcbiAgICAgICAgICAgICAgICAucHJvdmlkZXIoJ2JsdWVza3lIdHRwV3JhcHBlcicsIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyKTtcbiAgICAgICAgfSkoc2VydmljZXMgPSBjb3JlLnNlcnZpY2VzIHx8IChjb3JlLnNlcnZpY2VzID0ge30pKTtcbiAgICB9KShjb3JlID0gYmx1ZXNreS5jb3JlIHx8IChibHVlc2t5LmNvcmUgPSB7fSkpO1xufSkoYmx1ZXNreSB8fCAoYmx1ZXNreSA9IHt9KSk7XG5cbnZhciBibHVlc2t5O1xuKGZ1bmN0aW9uIChibHVlc2t5KSB7XG4gICAgdmFyIGNvcmU7XG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlcztcbiAgICAgICAgKGZ1bmN0aW9uIChzZXJ2aWNlcykge1xuICAgICAgICAgICAgdmFyIEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWxzLmNsaWVudENvbmZpZy5FbmRwb2ludFR5cGVFbnVtO1xuICAgICAgICAgICAgdmFyIEh0dHBNZXRob2Q7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKEh0dHBNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJHRVRcIl0gPSAwXSA9IFwiR0VUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUE9TVFwiXSA9IDFdID0gXCJQT1NUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUFVUXCJdID0gMl0gPSBcIlBVVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIkRFTEVURVwiXSA9IDNdID0gXCJERUxFVEVcIjtcbiAgICAgICAgICAgIH0pKEh0dHBNZXRob2QgfHwgKEh0dHBNZXRob2QgPSB7fSkpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIEJsdWVza3lIdHRwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIGN0b3JcbiAgICAgICAgICAgICAgICAvKiBAbmdJbmplY3QgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbHVlc2t5SHR0cFdyYXBwZXIoXywgJGh0dHAsICR3aW5kb3csICRsb2csICRxLCAkbG9jYXRpb24sIFVwbG9hZCwgdG9hc3RlciwgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwsIHNlbGVjdGVkVXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSAtIGZldGNoIHRoZSBjb25maWd1cmF0aW9uIGRhdGEgbmVjZXNzYXJ5IGZvciB0aGlzIHNlcnZpY2UgdG8gcnVuIGZyb20gdGhlIHByb3ZpZGVkIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXyA9IF87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2luZG93ID0gJHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nID0gJGxvZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcSA9ICRxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2NhdGlvbiA9ICRsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5VcGxvYWQgPSBVcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3RlciA9IHRvYXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnSW5pdGlhbGl6YXRpb25VUkwgPSBjb25maWdJbml0aWFsaXphdGlvblVSTDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFVzZXJSb2xlID0gc2VsZWN0ZWRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogUHJlcGFyZXMgYSB7QGxpbmsgbmcjJGh0dHAjY29uZmlnIGNvbmZpZ30gb2JqZWN0IGZvciAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAqICAtIEFqYXggY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgKiAgLSBBdXRob3JpemF0aW9uIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS5cbiAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtuZy4kaHR0cC5jb25maWd9IHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCByZWFkeSB0byBiZSBpbmplY3RlZCBpbnRvIGEgJGh0dHAgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVIdHRwQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVUkwgJiBNRVRIT0QgcGFyYW1ldGVycyBhcmUgbmVjZXNzYXJ5IGZvciBodHRwV3JhcHBlciBjYWxscy4gQWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBjb25maWcgdmFsdWVzIGFuZCBjdXN0b20gb25lcyBiYXNlZCBvbiBlbmRwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgPSBjb25maWcuZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjsgLy8gZGVmYXVsdCB2YWx1ZTogaWYgbm90IHNwZWNpZmllZCwgZW5kcG9pbnQgdG8gdXNlIGlzIHN1cHBvc2VkIHRvIGJlIHRoZSBvcmlnaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVuZHBvaW50IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYWtlIHN1cmUgRW5kcG9pbnRUeXBlRW51bVtpbnZhbGlkIHZhbHVlXSBkb2Vzbid0IHJldHVybiBkZWZhdWx0IHZhbGlkIGVudW0gdmFsdWUgPz8/IG90aGVyd2lzZSwgZGFuZ2Vyb3VzICFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RW5kcG9pbnRDb25maWcgPSBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZyAmJiBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5FbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBnZXQgYWxsIG5vbi1maWx0ZXJlZCBwYXJhbWV0ZXJzICYga2VlcCB0aGVtIGZvciB0aGlzIG5ldyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnRnVsbCA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHN1cHBvcnQgbWFwcGluZyBiZXR3ZWVuIHVwbG9hZCAmIHBvc3QgaGVyZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLm1ldGhvZCA9IEh0dHBNZXRob2RbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJlIGRlZmF1bHQgY29uZmlnIGZsYWdzIGJhc2VkIG9uIHRhcmdldCBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25maWcuZW5kcG9pbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLkNvcmVBcGk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk1hcmtldGluZ0FwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2VsZmNhcmVBcGk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBsaWNpdGx5IHdyb25nIGlucHV0IGNvbmZpZ3VyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLndhcm4oXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gQVBJIGNhbGwgaW50ZW5kZWQgd2l0aCBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBBYm9ydGluZyBhamF4IGNhbGwuXCIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWcgdmFsdWVzIGZvciBBUEkgZW5kcG9pbnRzIGFyZSBkaWZmZXJlbnQgZnJvbSBkZWZhdWx0LCBzbyB3ZSBtdXN0IHNwZWNpZnkgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlOyAvLyBieSBkZWZhdWx0IGFscmVhZHkgZW5hYmxlZCwgYnV0IGVuZm9yZSB0aGlzIGhlYWRlciBhcyBuZWNlc3NhcnkgZm9yIGNhbGxzIHRvIFdlYkFQSSBlbmRwb2ludHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlOyAvLyBmb3IgYXBpIGNhbGxzLCBmb3JjZSB0aGlzIHJvbGUgdG8gYmUgcGFzc2VkIGFyb3VuZCAoc2hvdWxkIGJlIG1hbmRhdG9yeSB0byBjb250ZXh0dWFsaXplIHJlcXVlc3QgdG8gcmVhbG0gb2YgY3VycmVudCB1c2VyKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlF1b3RlV2l6YXJkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5PcmRlckVudHJ5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5PcmRlclRyYWNraW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgT00gYXBwcyBjYWxsZWQgYXMgZW5kcG9pbnRzLCBtYWtlIHN1cmUgdGhlIFhtbEh0dHBSZXF1ZXN0IGhlYWRlciBpcyBwcmVzZW50IChBU1AuTkVUIGFwcHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGFkZCBjdXJyZW50VXNlclJvbGUgYnkgZGVmYXVsdCBzbyB0aGF0IE9NIGFwcHMgY2FuIGNvbnRleHR1YWxpc2UgdGhlIHJlcXVlc3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWV0cmFuZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlRlY2huaWNhbEludmVudG9yeTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVtcGxhdGVHZW5lcmF0b3I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlNhbGVzZm9yY2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG5vIHNwZWNpZmljIGNvbmZpZyBmb3IgdGhvc2UgZXh0ZXJuYWwgZW5kcG9pbnRzID8gYWRkIGN1c3RvbSBvbmVzIGlmIG5lZWRlZCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGFqYXggY2FsbHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIHRvIGNvbmZpcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IHRydWU7IC8vIGRvIG5vdCBhZGQgWG1sSHR0cFJlcXVlc3QgaWYgZXh0ZXJuYWwgVXJsIGJ5IGRlZmF1bHQ6IG1pZ2h0IGNyZWF0ZSBjb25mbGljdHMgb24gY2VydGFpbiBzZXJ2ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gVW5zdXBwb3J0ZWQgZW5kcG9pbnRUeXBlIHByb3ZpZGVkOiAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdICsgXCInLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9SZWplY3QgYWpheCBjYWxscyBpbnRlbmRlZCB0byBleHRlcm5hbCBlbmRwb2ludHMgd2l0aG91dCBuZWNlc3NhcnkgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEVuZHBvaW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBBamF4IGNhbGwgaW50ZW5kZWQgd2l0aG91dCBleHBlY3RlZCBlbmRwb2ludCBjb25maWd1cmF0aW9uIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIgZm9yIGVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdICsgXCInLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlIGlzIGVuYWJsZWQgKGFqYXggY2FsbHMgb24gLk5FVCBlbmRwb2ludHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWU6IGRvbid0IHRyYW5zbWl0IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0byByZW1vdGUgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGJ1aWxkIGEgdmFsaWQgdXJsIGZyb20gaW5wdXQgJiBlbmRwb2ludFR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLnVybCA9IF90aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQodXJsLCBjb25maWcuZW5kcG9pbnRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnRnVsbC51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIC0gVW5hYmxlIHRvIGJ1aWxkIHVybCBmcm9tIHVybElucHV0ICdcIiArIHVybCArIFwiJyB3aXRoIGVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdICsgXCInLiBBYm9ydGluZyBhamF4IGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGNhbGwgd2hlbiBtaXNzaW5nIG1hbmRhdG9yeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuQ3VycmVudFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgbmVjZXNzYXJ5IHVzZXJSb2xlIHNldCBpbiBjb25maWcuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snT0EtVXNlclJvbGUnXSA9IF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGF1dGggdG9rZW4gcHJvdmlkZWQgZm9yIHRhcmdldCBlbmRwb2ludCwgYWRkIGl0IGluIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbmRwb2ludENvbmZpZy5BdXRoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3QgYXV0aFRva2VuIGZvciBlbmRwb2ludHMgdGhhdCBhcmUgbm90ICdzYWZlJyB0byBzaGFyZSBhdXRoIHRva2VuIHdpdGgsIHN1Y2ggYXMgRXh0ZXJuYWwgb25lcyA/IE9yIGF1dGhvcml6ZSB0aGlzIHNvIHRoYXQgc2VydmVyIGNhbiBsb2FkIGFuIGF1dGggdG9rZW4gZm9yIGNlcnRhaW4gZXh0ZXJuYWwgZW5kcG9pbnRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgdG9rZW4gdmFsaWRpdHkgZW5kRGF0ZTogcmVuZXcgYXV0aCBiZWZvcmUgdGhlIGNhbGwgISBXaGF0J3MgdGhlIGJlc3QgbW9tZW50IHRvIGRvIGl0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIGN1cnJlbnRFbmRwb2ludENvbmZpZy5BdXRoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRSBzcGVjaWZpYyBjb2RlLCB0byByZW1vdmUsIG9yIGF0IGxlYXN0IHB1dCBpbiBhcyBjb25maWcgcGFyYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kd2luZG93LmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWdGdWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICAgICAgKiBDYXB0dXJlcyB0aGUgaW5wdXQgcGFyYW1ldGVycyBhdCB0aGUgbW9tZW50IG9mIGl0cyBkZWNsYXJhdGlvbiAmIHJldHVybiB0aGUgcmVhbCBoYW5kbGVyIHRvIGJlIGNhbGxlZCB1cG9uIHByb21pc2UgY29tcGxldGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICogSW5wdXQgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAgICAgICAgICogIC0gY2FsbGluZ0NvbmZpZzogY29uZmlndXJhdGlvbiB1c2VkIHRvIG1ha2UgdGhlIGFqYXggY2FsbCwgaW4gY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBudWxsL2VtcHR5IGFuZCBkb2Vzbid0IGNvbnRhaW4gbmVjZXNzYXJ5IGRhdGEgZm9yIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICAgICAgICogIC0gZ2V0Q29tcGxldGVSZXNwb25zZU9iamVjdDogZmxhZyBpbmRpY2F0aW9uIGlmIHdlIG11c3QgcmV0dXJuIHRoZSBmdWxsIHJlc3BvbnNlIG9iamVjdCBhbG9uZyB3aXRoIGhlYWRlcnMgYW5kIHN0YXR1cyBvciBvbmx5IHRoZSBpbm5lciBkYXRhLiBCeSBkZWZhdWx0ICYgaWYgbm90IHNwZWNpZmllZCwgb25seSByZXR1cm5zIGlubmVyIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChvcmlnaW5hbENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltIVFRQIG5vLXJlc3BvbnNlXSBVbmV4cGVjdGVkICRodHRwIGVycm9yLCBubyByZXNwb25zZSBwcm9taXNlIHJldHVybmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdVbmV4cGVjdGVkIGJlaGF2aW9yJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGlmIHN0YXR1cyAhPSAyWFggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRoaXMuJGxvZy5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgYnV0IG5vbmUgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmRlYnVnKFwiW0hUVFAgXCIgKyBodHRwUHJvbWlzZS5jb25maWcubWV0aG9kICsgXCJdIFtcIiArIGh0dHBQcm9taXNlLmNvbmZpZy51cmwgKyBcIl1cIiwgaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBFcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBhbmd1bGFyIHNpZ25hdHVyZXMgaW5kaWNhdGVzIHRoYXQgcGFyYW1ldGVyIGlzIHJlamVjdGlvbiByZWFzb24sIG5vdCBuZWNlc3NhcmlseSBodHRwUHJvbWlzZTogaW52ZXN0aWdhdGUgJiBmaXggaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBodHRwUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3VwcG9zZSBpbiBjYXNlIG9mIG5vIHJlc3BvbnNlIHRoYXQgdGhlIHNydiBkaWRuJ3Qgc2VuZCBhbnkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSB8fCAhaHR0cFByb21pc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5kYXRhID0gJ1NlcnZlciBub3QgcmVzcG9uZGluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgY29udGVudFR5cGUgdG8gdHJ5IHRvIGRpc3BsYXkgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlwiOyAvL2RlZmF1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIGVycm9yIGhhbmRsaW5nIG1vcmUgZ2VuZXJpY2FsbHkgYmFzZWQgb24gaW5wdXQgZXJyb3IgbWVzc2FnZSBjb250cmFjdCBpbnN0ZWFkIG9mIGV4cGVjdGluZyBzcGVjaWZpYyBlcnJvciBzdHJjdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHJlc3BvbnNlLmRhdGEuTW9kZWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLy9UT0RPIE1HQSA6IGhhbmRsZSB0aGlzIHdoZW4gd2VsbCBmb3JtYXR0ZWQgc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlICYmIGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgbW9yZSByZXNwb25zZSBjb2RlcyBncmFjZWZ1bGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci53YXJuaW5nKCdOb3QgRm91bmQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ1NlcnZlciByZXNwb25zZSBlcnJvcicsIG1lc3NhZ2UgKyAnXFxuIFN0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGRlc2lyZWQgc28gdGhhdCB3ZSBzaG93IGVycm9yIGluc2lkZSBzcGVjaWZpYyBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBtb2RhbHMgYXQgc3BlY2lmaWMgcGxhY2VzIGluIHRoZSBhcHAsIG90aGVyd2lzZSBzaG93IGEgZ2xvYmFsIGFsZXJ0IG1lc3NhZ2UsIG9yIGV2ZW4gZG8gbm90IHNob3cgYW55dGhpbmcgaWYgbm90IG5lY2Vzc2FyeSAoZG8gbm90IGFkIGFuIGVycm9yIGhhbmRsZXIgaW4gYmVsb3cgaGFuZGxlcnMgb2YgdGhpcyBwcm9taXNlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgKiBUT0RPIE1HQSBpbnZlcnNpb24gb2YgcmVzcG9uc2FiaWxpdHk6IG1ha2UgdGhpcyBleHRlbnNpYmxlIHNvIHRoYXQgc3BlY2lmYyBhcHBzIGNhbiBwbHVnIGludG8gdGhpcyBldmVudCB3b3JrZmxvd1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Utc3BlY2lmaWMgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJyB3aXRoIGVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW0VuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbl0gKyBcIicuIEFib3J0aW5nIGJsdWVza3lIdHRwU2VydmljZSBpbml0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBjdXN0b20gY29uZmlnIGZvciBoZWFkZXJzIGhhcmQgY29kZWQsIHRvIG11dHVhbGl6ZSB3aXRoIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZSA9IHRoaXMuJGh0dHAuZ2V0KGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCwgeyBoZWFkZXJzOiB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2xpZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IHN0YXR1cyBub3QgaW4gMlhYID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiVW5hYmxlIHRvIHJldHJpZXZlIGh0dHAgY29uZmlnIGRhdGEgZnJvbSAnXCIgKyBjb25maWdJbml0aWFsaXphdGlvblVSTCArIFwiJy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdG9hc3RlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgPSBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgYmx1ZXNreUh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4gU3J2IG1zZzogJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2hvdyB0b2FzdGVyID8gYmFzZWQgb24gcHJvdmlkZXIgY29uZmlnIGZsYWcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYmx1ZXNreUNsaWVudENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIGNhc2Ugd2hlcmUgY2xpZW50LXNpZGUgdXNlclJvbGUgd2FzIHByb3ZpZGVkIGFuZCBub3QgPT0gc3J2LXNpZGUgdXNlciByb2xlICFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmx1ZXNreUNsaWVudENvbmZpZy5DdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIG5vdCBwcm92aWRlZCBieSBkb21haW4gZnJvbSB3aGljaCBjb2RlIHdhcyBsb2FkZWQsIHRoZW4gdHJ5IHRvIGZldGNoIGRlZmF1bHQgdXNlclJvbGUgZnJvbSBDQVBJIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldCgndXNlci1zc28/cHJvZmlsZT0nLCB7IGVuZHBvaW50VHlwZTogRW5kcG9pbnRUeXBlRW51bS5Db3JlQXBpIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJTc28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyU3NvIHx8ICF1c2VyU3NvLlVzZXJSb2xlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnVW5hYmxlIHRvIHJldHJpZXZlIENvcmVBUEkgZGVmYXVsdCB1c2VyU1NPLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgc2VsZWN0ZWRVc2VyUm9sZSBpcyBhdmFpbGFibGUgaW4gdGhlIGxpc3Qgb2YgdXNlclNTTyByb2xlcywgb3RoZXJ3aXNlIHNlbGVjdCBkZWZhdWx0ICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGluZm9ybSBiYWNrIHRoZSBEQSB0aGF0IHNlbGVjdGVkVXNlclJvbGUgd2FzIHJlc2V0ID8gaW52ZXJ0IHJlc3BvbnNhYmlsaXR5ICYgc3RvcmUgdXNlclJvbGUgaW4gbG9jYWxTdG9yYWdlIGZyb20gdGhpcyBzZXJ2aWNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJSb2xlVG9Vc2UgPSBzZWxlY3RlZFVzZXJSb2xlIHx8IHVzZXJTc28uVXNlclJvbGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogdGhpcyBuZWVkcyB0byBiZSBwdXQgaW4gc2hhcmVkIGV4dGVuc2lvbiBtZXRob2QgLyBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UuTmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5Sb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLlNpbG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLkN1cnJlbnRVc2VyID0gdXNlclNzbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWVza3lDbGllbnRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB3ZSBvbmx5IGxvYWQgdXNlclNTTyBpZiBubyB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgc3J2LXNpZGUsIHNob3VsZCB3ZSBsb2FkIGl0IGluIGFsbCBjYXNlcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkIHVzZXJSb2xlIHNlbnQgZnJvbSBvcmlnaW4gYXBwLCB1c2UgaXQgJiBzZXQgaXQgYXMgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgbWV0aG9kc1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5ERUxFVEUsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh1cmwsIGZpbGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA/XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXBsb2FkSW5CYXNlNjRKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgdGhpcyBkZWxheXMgbmV4dCBjYWxsIGFuZCB1cGxvYWQgaXMgbm90IGRvbmUgYmVmb3JlIGJhc2U2NCBlbmNvZGluZyBpcyBmaW5pc2hlZCwgZXZlbiBpZiBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQgPz8/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQuYmFzZTY0RGF0YVVybChmaWxlKS50aGVuKGZ1bmN0aW9uIChmaWxlQmFzZTY0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZC1jb2RlZCBrZXkgdG8gZmV0Y2ggYmFzZTY0IGVuY29kaW5nLCB0byBwYXJhbWV0cml6ZSB3aXRoIHNlcnZlci1zaWRlICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlQmFzZTY0VXJsID0gZmlsZUJhc2U2NFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbCBwb3N0IGluIGNhc2Ugb2YgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSA/IChpbml0Q2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGJlaGF2aW9yIGR1cGxpY2F0aW9uIHdpdGggdGhpcy5hamF4LCBub3QgRFJZLCB0byBpbXByb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLlVwbG9hZC51cGxvYWQocmVxdWVzdENvbmZpZykgLy9UT0RPIE1HQSA6IG5vdCBzYWZlIGhhcmQgY2FzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMub25TdWNjZXNzKGNvbmZpZyksIF90aGlzLm9uRXJyb3IoY29uZmlnKSwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vVE9ETyBNR0E6IHdoYXQgdG8gcmV0dXJuID9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRvd25sb2FkIGEgZmlsZSBpbiB0aGUgZm9ybSBvZiBhIGJ5dGUtc3RyZWFtIGZyb20gYW4gZW5kcG9pbnQgYW5kIHdyYXAgaXQgaW50byBhIEZpbGVDb250ZW50IG9iamVjdCB3aXRoIG5hbWUsIHR5cGUgJiBzaXplIHByb3BlcnRpZXMgcmVhZCBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIHNlcnZldXIuXG4gICAgICAgICAgICAgICAgICogSXQgaXMgdGhlIHJlc3BvbnNhYmlsaXR5IG9mIHRoZSBjb25zdW1lciB0byBkbyBzb21ldGhpbmcgd2l0aCB0aGUgd3JhcHBlZCBieXRlQXJyYXkgKGZvciBleGFtcGxlIGRvd25sb2FkIHRoZSBmaWxlLCBvciBzaG93IGl0IGluc2lkZSB0aGUgd2ViUGFnZSBldGMpLlxuICAgICAgICAgICAgICAgICAqIFRPRE8gTUdBOiBub3QgRFJZIHdpdGggYWpheCBtZXRob2QsIGhvdyB0byBrZWVwIGl0IGluIHN5bmMgP1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWROYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkU2l6ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRGaWxlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFySHR0cENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoJ1VuYWJsZSB0byBjb25maWd1cmUgcmVxdWVzdCBjb3JyZWN0bHkuIEFib3J0aW5nIGdldEZpbGUgYWpheCBjYWxsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRXhwZWN0ZWQgQXJyYXlCdWZmZXIgcmVzcG9uc2UgPSBieXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmVuZWZpdCBmcm9tIHN1Y2Nlc3NDYWxsYmFjayB2YWxpZGF0aW9uIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gX3RoaXMub25TdWNjZXNzKGNvbmZpZykoaHR0cFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBwcm9taXNlIHJlamVjdGlvbiB2cy4gcmV0dXJuIG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVhZCBmaWxlIGluZm8gZnJvbSByZXNwb25zZS1oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTnVtYmVyKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWxlbmd0aCcpKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5vbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxuICAgICAgICAgICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKVxuICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gbnVsbCBpZiBub3QgYWJsZSB0byBjb21wdXRlIHVybC4gT3RoZXJ3aXNlLCB1cmwgb2YgdGhlIHJlcXVlc3QgZWl0aGVyIHBhcnRpYWwgb3IgZnVsbCBiYXNlZCBvbiBlbmRwb2ludFR5cGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5idWlsZFVybEZyb21Db250ZXh0ID0gZnVuY3Rpb24gKHVybElucHV0LCBlbmRwb2ludFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmxJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdObyBVUkwgaW5wdXQgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybignRnVsbCBVUkwgcHJvdmlkZWQgZm9yIGEgY2FsbCB0aGF0IGlzIG5vdCBmbGFnZ2VkIGFzIFxcJ0V4dGVybmFsXFwnIGVuZHBvaW50VHlwZSwgdGhpcyBpcyBiYWQgcHJhY3RpY2UgYXMgb25seSB0aGUgYmx1ZXNreVdyYXBwZXIgc2hvdWxkIGtub3cgYWJvdXQgdGhlIGJhc2VVUkwgb2YgdGFyZ2V0IGVuZHBvaW50cyAobG9hZGVkIGZyb20gc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52KS4gVXNlIHBhcnRpYWwgVVJMcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBoYXZlIGEgcGFydGlhbCBVUkwgdG8gY29tcGxldGU6IHVzZSBwcm92aWRlZCBlbmRwb2ludCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gY29tcGxldGUgdXJsLlxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciBlbmRwb2ludFR5cGUgaWYgbm90IHByb3ZpZGVkIGlzIG9yaWdpbi4gVE9ETyBNR0E6IHJ1bGUgdG8gZGlzY3VzcywgaGVyZSBmb3IgcmV0cm8tY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRUeXBlID0gZW5kcG9pbnRUeXBlIHx8IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy53YXJuKCdQYXJ0aWFsIHVybCBwcm92aWRlZCBmb3IgYSBjYWxsIHdpdGggZW5kcG9pbnRUeXBlIGZsYWdnZWQgYXMgXFwnRXh0ZXJuYWxcXCc6IHRoZSBjYWxsIHdpbGwgcHJvYmFibHkgZmFpbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgcHJvdmlkZWQgdXJsIGlmIGV4dGVybmFsICh3ZSBjYW5ub3Qga25vdyBob3cgdG8gY29tcGxldGUgaXQsIGV2ZW4gaWYgcGFydGlhbCkuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9pbnRUeXBlID09PSBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleCA9IC9cXHcrXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgZW5kcG9pbnRUeXBlczogY29tcHV0ZSBVUkwgYXMgYSBjb21iaW5hdGlvbiBvZiBiYXNlVVJMICYgc3VmZml4IGlmIHByZXNlbnQsIGFzIHByb3ZpZGVkIGJ5IHNlcnZlci1jb25maWd1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0V4cGVjdGVkIGVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5IHByb3ZpZGVkIGJ1dCBub25lIGZvdW5kLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIEhBQ0tZOiBzZWFyY2ggYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVuZHBvaW50IHR5cGUgaW4gZGljdCBkdWUgdG8gc2VyaWFsaXphdGlvbiBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludENvbmZpZyA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuRW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbRW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5kcG9pbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoXCJFbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdICsgXCInIGlzIG5vdCAnRXh0ZXJuYWwnIG9yICdDdXJyZW50RG9tYWluJywgZXhwZWN0ZWQgY29ycmVzcG9uZGluZyBlbmRwb2ludENvbmZpZ3VyYXRpb24gcHJvdmlkZWQgaW4gYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBlbmRwb2ludENvbmZpZy5FbmRwb2ludEJhc2VVUkwgKyAoZW5kcG9pbnRDb25maWcuRW5kcG9pbnRTdWZmaXggfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIG1heSBmYWlsID9cbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbiB1c2VkIHRvIHRyeSB0byBkZXRlcm1pbmUgY29ycmVjdCBmdWxsIHVybCAoYWRkIC8gb3Igbm90IGJlZm9yZSB0aGUgdXJsIGZyYWdtZW50IGRlcGVuZGluZyBvbiBpZiBmb3VuZCBvciBub3QpXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA9IHVybElucHV0LnNsaWNlKDAsIDEpID09PSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoID0gYmFzZVVybC5zbGljZShiYXNlVXJsLmxlbmd0aCAtIDEsIGJhc2VVcmwubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAvL2Jhc2VkIG9uIHN0YXJ0aW5nL3RyYWlsaW5nIHNsYXNoZXMsIHJldHVybiBmdWxsIHVybC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGFzdCAnLycgb24gYmFzZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwuc2xpY2UoMCwgYmFzZVVybC5sZW5ndGggLSAxKSArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICcvJyArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiAhdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggJiYgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXRpbGl0eSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICogTWFpbiBjYWxsZXIgdGhhdCBhbGwgd3JhcHBlciBjYWxscyAoZ2V0LCBkZWxldGUsIHBvc3QsIHB1dCkgbXVzdCB1c2UgdG8gc2hhcmUgY29tbW9uIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFrZSBzdXJlIGdldENvbmZpZyByZXNvbHZlIGF1dG9tYXRpY2FsbHkgd2l0aG91dCBvdmVyaGVhZCBvbmNlIGZpcnN0IGNhbGwgc3VjZXNzZnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gX3RoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKGFuZ3VsYXJIdHRwQ29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihfdGhpcy5vblN1Y2Nlc3MoY29uZmlnKSwgX3RoaXMub25FcnJvcihjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVzaW5nIG1ldGhvZCBmcm9tIExheW91dC5qcyA6IHRvIGRvY3VtZW50IHRvIG5vdCBoYW5kbGUgZHVwbGljYXRlIGNvZGUgISFcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB1bnJvYnVzdCwgbmVlZHMgc29saWQgcmVmYWN0byB0byBtYWtlIGl0IG1vcmUgZ2VuZXJpYyB3aGVuIG9uIG9yaWdpbiBkb21haW4gIVxuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0VXJsUGF0aCA9IGZ1bmN0aW9uIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNSZWdleCA9IC8oXFwvXFx3KylcXC9cXHcrLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuJHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNNYXRjaGVzID0gYmFzZVVybE9tQXBwc1JlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyA9IGJhc2VVcmxBc3BBcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBtYXRjaGVzID0gcmVnZXggbWF0Y2hlcyArIHRoZSBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxPbUFwcHNNYXRjaGVzICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsT21BcHBzTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybEFzcEFwcHNNYXRjaGVzICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPTS1zcGVjaWZpYyBBU1AgTVZDIGNvZGUsIG5vdCB1c2VkIEFUTSwgdG8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRDdXJyZW50U2Vzc2lvbklEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFnaWMgcmVnZXhwIHRvIGZldGNoIFNlc3Npb25JRCBpbiBVUkwsIHRvIHN0b3JlIGVsc2V3aGVyZSAhXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uUmVnZXggPSAvaHR0cHM6XFwvXFwvW1xcdy5dK1xcL1tcXHcuXStcXC8oXFwoU1xcKFxcdytcXClcXCkpXFwvLiovO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBzZXNzaW9uUmVnZXggPSAvaHR0cHM6XFwvXFwvW1xcdy5dK1xcL09yZGVyRW50cnlcXC8oXFwoU1xcKFxcdytcXClcXCkpXFwvLiovO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVwZGF0ZSByZWdleHAgdG8gdGhlIG9uZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBiYXNlVXJsUmVnZXggPSAvKGh0dHBzOlxcL1xcL1tcXHcuLV0rXFwvW1xcdy4tXStcXC9cXChTXFwoXFx3K1xcKVxcKVxcLylcXHcrLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLiRsb2NhdGlvbi5hYnNVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4cEFycmF5ID0gc2Vzc2lvblJlZ2V4LmV4ZWMocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cEFycmF5WzFdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVHJpbSB0aGUgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgdG8gcmV0dXJuIG9ubHkgdGhlIGZpbGVuYW1lLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb250ZW50RGlzcG9zaXRpb25IZWFkZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEZpbGVOYW1lRnJvbUhlYWRlckNvbnRlbnREaXNwb3NpdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbHVlc2t5SHR0cFdyYXBwZXI7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyID0gQmx1ZXNreUh0dHBXcmFwcGVyO1xuICAgICAgICB9KShzZXJ2aWNlcyA9IGNvcmUuc2VydmljZXMgfHwgKGNvcmUuc2VydmljZXMgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
