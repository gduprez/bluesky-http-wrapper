



var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            /**
             * Provider for the BlueskyHttpWrapper.
             * Enables per-consumer configuration of the http service to set custom configuration URL to fetch data from:
             *  - Client initial configuration URL from the origin the app was loaded from.
             *  - UserRole to use of already fetched from another place.
             */
            var BlueskyHttpWrapperProvider = (function () {
                function BlueskyHttpWrapperProvider() {
                    var _this = this;
                    //#region private properties
                    this.getClientConfigInitializationUrl = 'BlueskyAjaxClientConfiguration/GetAjaxClientConfiguration'; // by default.
                    this.selectedUserRole = null; // by default not-set.
                    //#endregion
                    // Provider's factory function
                    /* @ngInject */
                    this.$get = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", function (_, $http, $window, $log, $q, $location, Upload, toaster) {
                        return new services.BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, _this.getClientConfigInitializationUrl, _this.selectedUserRole);
                    }];
                    this.$get.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                }
                //#endregion
                //#region public configuration methods
                BlueskyHttpWrapperProvider.prototype.setClientConfigURL = function (clientConfigUrlToUse) {
                    this.getClientConfigInitializationUrl = clientConfigUrlToUse || this.getClientConfigInitializationUrl;
                };
                BlueskyHttpWrapperProvider.prototype.setUserRoleToUse = function (userRole) {
                    this.selectedUserRole = userRole || null;
                };
                return BlueskyHttpWrapperProvider;
            }());
            services.BlueskyHttpWrapperProvider = BlueskyHttpWrapperProvider;
            angular.module('bluesky.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .constant('_', window._)
                .constant('moment', window.moment)
                .provider('blueskyHttpWrapper', BlueskyHttpWrapperProvider);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var EndpointTypeEnum = bluesky.core.models.clientConfig.EndpointTypeEnum;
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            var BlueskyHttpWrapper = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                BlueskyHttpWrapper.$inject = ["_", "$http", "$window", "$log", "$q", "$location", "Upload", "toaster", "configInitializationURL", "selectedUserRole"];
                function BlueskyHttpWrapper(_, $http, $window, $log, $q, $location, Upload, toaster, configInitializationURL, selectedUserRole) {
                    // 1 - fetch the configuration data necessary for this service to run from the provided endpoint
                    var _this = this;
                    this._ = _;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    this.configInitializationURL = configInitializationURL;
                    this.selectedUserRole = selectedUserRole;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        // input validation
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        // set default config values and custom ones based on endpoints
                        config = config || {};
                        config.endpointType = config.endpointType || EndpointTypeEnum.CurrentDomain; // default value: if not specified, endpoint to use is supposed to be the origin.
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        configFull.headers = config.headers || {};
                        // configure default config flags based on target endpoint
                        switch (config.endpointType) {
                            case EndpointTypeEnum.CoreApi:
                            case EndpointTypeEnum.MarketingApi:
                            case EndpointTypeEnum.SelfcareApi:
                                // Reject explicitly wrong input configurations
                                if (config.disableXmlHttpRequestHeader) {
                                    _this.$log.warn("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - API call intended with incompatible configuration options. Aborting ajax call.", config);
                                    return null;
                                }
                                // config values for API endpoints are different from default, so we must specify them.
                                config.disableXmlHttpRequestHeader = false; // by default already enabled, but enfore this header as necessary for calls to WebAPI endpoints.
                                config.useCurrentUserRole = true; // for api calls, force this role to be passed around (should be mandatory to contextualize request to realm of current user).
                                break;
                            case EndpointTypeEnum.QuoteWizard:
                            case EndpointTypeEnum.OrderEntry:
                            case EndpointTypeEnum.OrderTracking:
                                // for OM apps called as endpoints, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                //TODO MGA: add currentUserRole by default so that OM apps can contextualise the request ?
                                break;
                            case EndpointTypeEnum.Metranet:
                            case EndpointTypeEnum.TechnicalInventory:
                            case EndpointTypeEnum.TemplateGenerator:
                            case EndpointTypeEnum.Salesforce:
                                //TODO MGA: no specific config for those external endpoints ? add custom ones if needed here.
                                break;
                            case EndpointTypeEnum.CurrentDomain:
                                // for ajax calls, make sure the XmlHttpRequest header is present (ASP.NET apps).
                                config.disableXmlHttpRequestHeader = false;
                                break;
                            case EndpointTypeEnum.External:
                                //TODO MGA to confirm
                                config.disableXmlHttpRequestHeader = true; // do not add XmlHttpRequest if external Url by default: might create conflicts on certain servers.
                                break;
                            default:
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall][" + configFull.method + " / " + url + "] - Unsupported endpointType provided: '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.");
                                break;
                        }
                        //Reject ajax calls intended to external endpoints without necessary configuration loaded from the server.
                        if (config.endpointType !== EndpointTypeEnum.CurrentDomain &&
                            config.endpointType !== EndpointTypeEnum.External &&
                            (!_this.blueskyAjaxClientConfig ||
                                !_this.blueskyAjaxClientConfig.endpointConfigurationDictionnary[config.endpointType])) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without expected endpoint configuration loaded from the server for endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting.");
                            return null;
                        }
                        //TODO MGA: set default values after endpoint-specific configurations
                        config.disableXmlHttpRequestHeader = config.disableXmlHttpRequestHeader || false; // default value is enabled (ajax calls on .NET endpoints).
                        config.useCurrentUserRole = config.useCurrentUserRole || false; // default value: don't transmit sensitive information to remote if not explicitly specified.
                        config.disableToasterNotifications = config.disableToasterNotifications || false; //set default value for disableToasterNotifications to false as it's part of the normal behavior expected for this service.
                        // Try to build a valid url from input & endpointType.
                        configFull.url = _this.buildUrlFromContext(url, config.endpointType);
                        if (!configFull.url) {
                            _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] - Unable to build url from urlInput '" + url + "' with endpointType '" + EndpointTypeEnum[config.endpointType] + "'. Aborting ajax call.");
                            return null;
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        if (config.useCurrentUserRole) {
                            // Reject call when missing mandatory information
                            if (!_this.blueskyAjaxClientConfig.currentUserRole) {
                                _this.$log.error("[BlueskyHttpWrapper][configureHttpCall] [" + configFull.method + " / " + url + "] - Ajax call intended without necessary userRole set in config. Aborting.");
                                return null;
                            }
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['OA-UserRole'] = _this.blueskyAjaxClientConfig.currentUserRole;
                        }
                        var currentEndpointConfig = _this.blueskyAjaxClientConfig && _this.blueskyAjaxClientConfig.endpointConfigurationDictionnary[config.endpointType];
                        // If auth token provided for target endpoint, add it in header
                        if (currentEndpointConfig.authToken) {
                            //TODO MGA: reject authToken for endpoints that are not 'safe' to share auth token with, such as External ones ? Or authorize this so that server can load an auth token for certain external endpoints ?
                            //TODO MGA: handle token validity endDate: renew auth before the call ! What's the best moment to do it ?
                            //TODO MGA: hard coded header to put in CONST
                            configFull.headers['Authorization'] = 'Bearer ' + currentEndpointConfig.authToken;
                        }
                        //TODO MGA: OE specific code, to remove, or at least put in as config param
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (originalConfig) {
                        return function (httpPromise) {
                            if (!httpPromise) {
                                _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                                if (!originalConfig.disableToasterNotifications)
                                    _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                                return null;
                            }
                            //TODO MGA: reject if status != 2XX ?
                            //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                            //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                            //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                            //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                            //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                            //}
                            //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                            //TODO MGA: get full url of request
                            _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // return only the data expected for caller
                            return httpPromise.data;
                        };
                    };
                    /**
                     * Error handler
                     * TODO MGA: angular signatures indicates that parameter is rejection reason, not necessarily httpPromise: investigate & fix if necessary
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (originalConfig) {
                        return function (httpPromise) {
                            // We suppose in case of no response that the srv didn't send any response.
                            // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                            if (!httpPromise || !httpPromise.data) {
                                httpPromise.data = 'Server not responding';
                                httpPromise.status = 503;
                            }
                            if (!originalConfig.disableToasterNotifications) {
                                var contentType = httpPromise.headers('Content-Type');
                                //check contentType to try to display error message
                                if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                                    var message = ""; //default message
                                    //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                                    //if (response.data.ModelState) {
                                    //    //TODO MGA : handle this when well formatted server-side
                                    //} else
                                    if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                        message = httpPromise.data.Message;
                                    }
                                    else if (angular.isString(httpPromise.data)) {
                                        message = httpPromise.data;
                                    }
                                    //TODO MGA: handle more response codes gracefully.
                                    if (httpPromise.status === 404) {
                                        _this.toaster.warning('Not Found', message);
                                    }
                                    else {
                                        _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                                    }
                                }
                                else {
                                    _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                                }
                            }
                            //TODO MGA: get full url of request
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                            // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                            // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                            return _this.$q.reject(httpPromise);
                        };
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     * TODO MGA inversion of responsability: make this extensible so that specifc apps can plug into this event workflow
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    var configurationEndpointUrl = this.buildUrlFromContext(configInitializationURL, EndpointTypeEnum.CurrentDomain);
                    if (!configurationEndpointUrl) {
                        this.$log.error("[BlueskyHttpWrapper][Initialization] - Unable to build url from initialConfig url '" + configInitializationURL + "' with endpointType '" + EndpointTypeEnum[EndpointTypeEnum.CurrentDomain] + "'. Aborting blueskyHttpService init.");
                        return;
                    }
                    this.getConfigPromise = this.$http.get(configurationEndpointUrl)
                        .then(
                    // success
                    function (clientConfigPromise) {
                        //TODO MGA: reject status not in 2XX ?
                        if (!clientConfigPromise.data) {
                            var msg = "Unable to retrieve http config data from '" + configInitializationURL + "'. Aborting blueskyHttpWrapperService initialization.";
                            _this.$log.error(msg);
                            //TODO MGA: toaster ?
                            return _this.$q.reject(msg);
                        }
                        _this.blueskyAjaxClientConfig = clientConfigPromise.data;
                        return clientConfigPromise.data;
                    }, 
                    // error
                    function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting blueskyHttpWrapperService initialization.');
                        return _this.$q.reject(error);
                    })
                        .then(
                    // success
                    function (blueskyClientConfig) {
                        //TODO MGA: handle case where client-side userRole was provided and not == srv-side user role !
                        if (!blueskyClientConfig.currentUserRole) {
                            //If not provided by domain from which code was loaded, then try to fetch default userRole from CAPI endpoint
                            return _this.get('user-sso?profile=', { endpointType: EndpointTypeEnum.CoreApi }).then(function (userSso) {
                                if (!userSso || !userSso.userRoleEntry) {
                                    var msg = 'Unable to retrieve CoreAPI default userSSO. Aborting httpWrapperService initialization.';
                                    _this.$log.error(msg);
                                    return _this.$q.reject(msg);
                                }
                                //TODO MGA: make sure selectedUserRole is available in the list of userSSO roles, otherwise select default !
                                //TODO MGA: how to inform back the DA that selectedUserRole was reset ? invert responsability & store userRole in localStorage from this service ?
                                var userRoleToUse = selectedUserRole || userSso.userRoleEntry;
                                //TODO MGA: this needs to be put in shared extension method / service
                                _this.blueskyAjaxClientConfig.currentUserRole = userRoleToUse.name + " " + userRoleToUse.role + " " + userRoleToUse.silo;
                                _this.blueskyAjaxClientConfig.currentUser = userSso;
                                return blueskyClientConfig;
                            });
                        }
                        else {
                            //TODO MGA: we only load userSSO if no userRole was provided srv-side, should we load it in all cases ?
                            // already defined userRole sent from origin app, use it & set it as default.
                            return blueskyClientConfig;
                        }
                    });
                }
                //#endregion
                //#region public methods
                BlueskyHttpWrapper.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                BlueskyHttpWrapper.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                BlueskyHttpWrapper.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                BlueskyHttpWrapper.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                /**
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param file
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IBlueskyHttpRequestConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API ? (initCall)
                        return this.getConfigPromise.then(function () {
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            var requestConfig = _this.configureHttpCall(HttpMethod.POST, url, config);
                            if (requestConfig)
                                return _this.Upload.upload(requestConfig) //TODO MGA : not safe hard cast
                                    .then(_this.onSuccess(config), _this.onError(config), config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                    .finally(_this.finally);
                            return null; //TODO MGA: what to return ?
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * TODO MGA: not DRY with ajax method, how to keep it in sync ?
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // if no config returned, configuration failed, do not start ajax request
                        if (!angularHttpConfig) {
                            return _this.$q.reject('Unable to configure request correctly. Aborting getFile ajax call.');
                        }
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(config)(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 * @return null if not able to compute url. Otherwise, url of the request either partial or full based on endpointType.
                 */
                BlueskyHttpWrapper.prototype.buildUrlFromContext = function (urlInput, endpointType) {
                    if (!urlInput) {
                        this.$log.error('No URL input provided.');
                        return null;
                    }
                    // If Url starts with http:// or https:// => return as is, even if endpointType is not external.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        if (endpointType !== EndpointTypeEnum.External)
                            this.$log.warn('Full URL provided for a call that is not flagged as \'External\' endpointType, this is bad practice as only the blueskyWrapper should know about the baseURL of target endpoints (loaded from server, depending on the current env). Use partial URLs.');
                        return urlInput;
                    }
                    // Else, we have a partial URL to complete: use provided endpoint type to determine how to complete url.
                    // Default value for endpointType if not provided is origin. TODO MGA: rule to discuss, here for retro-compatibility.
                    endpointType = endpointType || EndpointTypeEnum.CurrentDomain;
                    var baseUrl;
                    if (endpointType === EndpointTypeEnum.External) {
                        this.$log.warn('Partial url provided for a call with endpointType flagged as \'External\': the call will probably fail.');
                        // do not modify provided url if external (we cannot know how to complete it, even if partial).
                        return urlInput;
                    }
                    else if (endpointType === EndpointTypeEnum.CurrentDomain) {
                        // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                        var controllerIsPresentRegex = /\w+\/\w+/;
                        var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                        baseUrl = this.getUrlPath(actionIsOnSameController);
                    }
                    else {
                        // For all other endpointTypes: compute URL as a combination of baseURL & suffix if present, as provided by server-configuration.
                        if (!this.blueskyAjaxClientConfig ||
                            !this.blueskyAjaxClientConfig.endpointConfigurationDictionnary) {
                            this.$log.error('Expected endpointConfigurationDictionnary provided but none found. Aborting.');
                            return null;
                        }
                        var endpointConfig = this.blueskyAjaxClientConfig.endpointConfigurationDictionnary[endpointType];
                        if (!endpointConfig) {
                            this.$log.error("EndpointType '" + EndpointTypeEnum[endpointType] + "' is not 'External' or 'CurrentDomain', expected corresponding endpointConfiguration provided in blueskyAjaxClientConfig.endpointConfigurationDictionnary but none found. Aborting.");
                            return null;
                        }
                        baseUrl = endpointConfig.endpointBaseURL + (endpointConfig.endpointSuffix || '');
                    }
                    //TODO MGA: how to handle OM apps external calls without session provided ? will result in a redirect and call may fail ?
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, 1) === '/';
                    var baseUrlFragmentEndsWithSlash = baseUrl.slice(baseUrl.length - 1, baseUrl.length) === '/';
                    //based on starting/trailing slashes, return full url.
                    if (baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash)
                        // remove last '/' on baseUrl
                        return baseUrl.slice(0, baseUrl.length - 1) + urlInput;
                    else if (!baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash)
                        return baseUrl + '/' + urlInput;
                    else if ((baseUrlFragmentEndsWithSlash && !urlFragmentStartsWithSlash) ||
                        (!baseUrlFragmentEndsWithSlash && urlFragmentStartsWithSlash))
                        return baseUrl + urlInput;
                    return null;
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                BlueskyHttpWrapper.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure getConfig resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.getConfigPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        if (angularHttpConfig)
                            return _this.$http(angularHttpConfig)
                                .then(_this.onSuccess(config), _this.onError(config))
                                .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                BlueskyHttpWrapper.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = null;
                    var baseUrl = null;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                BlueskyHttpWrapper.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                BlueskyHttpWrapper.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return BlueskyHttpWrapper;
            }());
            services.BlueskyHttpWrapper = BlueskyHttpWrapper;
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1vZGVscy9ibHVlc2t5LWh0dHAtcmVxdWVzdC1jb25maWcubW9kZWwudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5wcm92aWRlci50cyIsImJsdWVza3ktaHR0cC13cmFwcGVyLnNlcnZpY2UudHMiLCJibHVlc2t5LWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFxQkM7Ozs7QUNyQkQsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxVQUFTOzs7Ozs7O1lBUzVCLElBQUEsOEJBQUEsWUFBQTtnQkFBQSxTQUFBLDZCQUFBO29CQUFBLElBQUEsUUFBQTs7b0JBSVksS0FBQSxtQ0FBMkM7b0JBQzNDLEtBQUEsbUJBQXFDOzs7O29CQWtCdEMsS0FBQSxpRkFBTyxVQUFDLEdBQ1gsT0FDQSxTQUNBLE1BQ0EsSUFDQSxXQUNBLFFBQ0EsU0FBa0M7d0JBRWxDLE9BQU8sSUFBSSxTQUFTLG1CQUFtQixHQUFHLE9BQU8sU0FBUyxNQUFNLElBQUksV0FBVyxRQUFRLFNBQVMsTUFBSyxrQ0FBa0MsTUFBSzs7Ozs7O2dCQXJCekksMkJBQUEsVUFBQSxxQkFBUCxVQUEwQixzQkFBNEI7b0JBQ2xELEtBQUssbUNBQW1DLHdCQUF3QixLQUFLOztnQkFHbEUsMkJBQUEsVUFBQSxtQkFBUCxVQUF3QixVQUEwQjtvQkFDOUMsS0FBSyxtQkFBbUIsWUFBWTs7Z0JBa0I1QyxPQUFBOztZQWxDYSxTQUFBLDZCQUEwQjtZQW9DdkMsUUFBUSxPQUFPLHVCQUF1QixDQUFDLFdBQVcsYUFBYTtpQkFDMUQsU0FBMkIsS0FBSyxPQUFPO2lCQUN2QyxTQUE4QixVQUFVLE9BQU87aUJBQy9DLFNBQVMsc0JBQXNCO1dBaERqQixXQUFBLEtBQUEsYUFBQSxLQUFBLFdBQVE7T0FBYixPQUFBLFFBQUEsU0FBQSxRQUFBLE9BQUk7R0FBWixZQUFBLFVBQU87O0FDQWpCLElB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QkFJSCxtQkFBQSxVQUFBLHNCQUFSLFlBQUE7O29CQUdJLElBQUksZUFBZTs7OztvQkFPbkIsSUFBSSxPQUFPLEtBQUssVUFBVTtvQkFFMUIsSUFBSSxjQUFjLGFBQWEsS0FBSztvQkFFcEMsSUFBSSxDQUFDLGFBQWE7d0JBQ2QsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUVYLElBQUksWUFBWSxXQUFXLEdBQUc7d0JBQzFCLEtBQUssS0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFFWCxJQUFJLFlBQVksU0FBUyxHQUFHO3dCQUN4QixLQUFLLEtBQUssTUFBTTt3QkFDaEIsT0FBTzs7b0JBR1gsT0FBTyxZQUFZOzs7Ozs7Z0JBT2YsbUJBQUEsVUFBQSwwQ0FBUixVQUFnRCwwQkFBZ0M7b0JBQzVFLElBQUksQ0FBQzt3QkFBMEIsT0FBTztvQkFFdEMsSUFBSSxTQUFTLHlCQUF5QixNQUFNLEtBQUssR0FBRyxPQUFPLE1BQU0sS0FBSztvQkFFdEUsT0FBTyxPQUFPLFFBQVEsTUFBTTs7Z0JBSXBDLE9BQUE7O1lBeG5CYSxTQUFBLHFCQUFrQjtXQXJDWixXQUFBLEtBQUEsYUFBQSxLQUFBLFdBQVE7T0FBYixPQUFBLFFBQUEsU0FBQSxRQUFBLE9BQUk7R0FBWixZQUFBLFVBQU87QUM0akJqQiIsImZpbGUiOiJibHVlc2t5LWh0dHAtd3JhcHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIm5hbWVzcGFjZSBibHVlc2t5LmNvcmUubW9kZWxzLmJsdWVza3lIdHRwQ2xpZW50IHtcclxuXHJcbiAgICBpbXBvcnQgRW5kcG9pbnRUeXBlRW51bSA9IGNvcmUubW9kZWxzLmNsaWVudENvbmZpZy5FbmRwb2ludFR5cGVFbnVtO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETyBNR0EgRG9jXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyBleHRlbmRzIG5nLklSZXF1ZXN0U2hvcnRjdXRDb25maWcge1xyXG5cclxuICAgICAgICBlbmRwb2ludFR5cGU/OiBFbmRwb2ludFR5cGVFbnVtO1xyXG5cclxuICAgICAgICB1c2VDdXJyZW50VXNlclJvbGU/OiBib29sZWFuO1xyXG4gICAgICAgIGRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcj86IGJvb2xlYW47XHJcbiAgICAgICAgZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zPzogYm9vbGVhbjtcclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogZW5jYXBzdWxhdGUgaW4gYW4gVXBsb2FkQ29uZmlnIG9iamVjdFxyXG4gICAgICAgIGZpbGU/OiBGaWxlLFxyXG4gICAgICAgIHVwbG9hZEluQmFzZTY0SnNvbj86IGJvb2xlYW47XHJcbiAgICAgICAgdXBsb2FkUHJvZ3Jlc3M/OiAoKSA9PiBhbnk7XHJcblxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5zZXJ2aWNlcyB7XHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuVXNlclJvbGVFbnRyeUR0bztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxyXG4gICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxyXG4gICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxyXG4gICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciBpbXBsZW1lbnRzIG5nLklTZXJ2aWNlUHJvdmlkZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25Vcmw6IHN0cmluZyA9ICdCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb24vR2V0QWpheENsaWVudENvbmZpZ3VyYXRpb24nOyAvLyBieSBkZWZhdWx0LlxyXG4gICAgICAgIHByaXZhdGUgc2VsZWN0ZWRVc2VyUm9sZTogVXNlclJvbGVFbnRyeUR0byA9IG51bGw7IC8vIGJ5IGRlZmF1bHQgbm90LXNldC5cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgY29uZmlndXJhdGlvbiBtZXRob2RzXHJcblxyXG4gICAgICAgIHB1YmxpYyBzZXRDbGllbnRDb25maWdVUkwoY2xpZW50Q29uZmlnVXJsVG9Vc2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsID0gY2xpZW50Q29uZmlnVXJsVG9Vc2UgfHwgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzZXRVc2VyUm9sZVRvVXNlKHVzZXJSb2xlOiBVc2VyUm9sZUVudHJ5RHRvKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSA9IHVzZXJSb2xlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZXIncyBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgcHVibGljICRnZXQgPSAoXzogVW5kZXJzY29yZVN0YXRpYyxcclxuICAgICAgICAgICAgJGh0dHA6IG5nLklIdHRwU2VydmljZSxcclxuICAgICAgICAgICAgJHdpbmRvdzogbmcuSVdpbmRvd1NlcnZpY2UsXHJcbiAgICAgICAgICAgICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkcTogbmcuSVFTZXJ2aWNlLFxyXG4gICAgICAgICAgICAkbG9jYXRpb246IG5nLklMb2NhdGlvblNlcnZpY2UsXHJcbiAgICAgICAgICAgIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHRvYXN0ZXI6IG5ndG9hc3Rlci5JVG9hc3RlclNlcnZpY2UpOiBzZXJ2aWNlcy5JQmx1ZXNreUh0dHBXcmFwcGVyID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIsIHRoaXMuZ2V0Q2xpZW50Q29uZmlnSW5pdGlhbGl6YXRpb25VcmwsIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFuZ3VsYXIubW9kdWxlKCdibHVlc2t5Lmh0dHBXcmFwcGVyJywgWyd0b2FzdGVyJywgJ25nQW5pbWF0ZScsICduZ0ZpbGVVcGxvYWQnXSlcclxuICAgICAgICAuY29uc3RhbnQ8VW5kZXJzY29yZVN0YXRpYz4oJ18nLCB3aW5kb3cuXylcclxuICAgICAgICAuY29uc3RhbnQ8bW9tZW50Lk1vbWVudFN0YXRpYz4oJ21vbWVudCcsIHdpbmRvdy5tb21lbnQpXHJcbiAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XHJcbn0iLCJuYW1lc3BhY2UgYmx1ZXNreS5jb3JlLnNlcnZpY2VzIHtcclxuXHJcbiAgICBpbXBvcnQgVXNlclJvbGVFbnRyeUR0byA9IGJsdWVza3kuY29yZS5tb2RlbHMudXNlck1hbmFnZW1lbnQuVXNlclJvbGVFbnRyeUR0bztcclxuICAgIGltcG9ydCBVc2VyU3NvRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVscy51c2VyTWFuYWdlbWVudC5Vc2VyU3NvRHRvO1xyXG4gICAgaW1wb3J0IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyA9IGJsdWVza3kuY29yZS5tb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQuSUJsdWVza3lIdHRwUmVxdWVzdENvbmZpZztcclxuICAgIGltcG9ydCBGaWxlQ29udGVudCA9IGJsdWVza3kuY29yZS5tb2RlbHMuYmx1ZXNreUh0dHBDbGllbnQuRmlsZUNvbnRlbnQ7XHJcbiAgICBpbXBvcnQgQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvID0gYmx1ZXNreS5jb3JlLm1vZGVscy5jbGllbnRDb25maWcuQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG4gICAgaW1wb3J0IEVuZHBvaW50VHlwZUVudW0gPSBibHVlc2t5LmNvcmUubW9kZWxzLmNsaWVudENvbmZpZy5FbmRwb2ludFR5cGVFbnVtO1xyXG5cclxuICAgIGVudW0gSHR0cE1ldGhvZCB7IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE8gTUdBIGNvbW1lbnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJQmx1ZXNreUh0dHBXcmFwcGVyIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIHNydi1zaWRlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBodHRwIGNsaWVudCwgcHJvdmlkZWQgYnkgdGhlIGluamVjdGVkICdjb25maWdJbml0aWFsaXphdGlvblVSTCcgZW5kcG9pbnQuXHJcbiAgICAgICAgICogVGhpcyBjb25maWd1cmF0aW9uIGRhdGEgaXMgbG9hZGVkIHVwb24gaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBzZXJ2aWNlICh0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uIGluIHRoZSBhcHApLiBBbGwgb3RoZXIgd2ViIGNhbGxzIGFyZSBibG9ja2VkIGFzIGxvbmcgYXMgdGhpcyBvbmUgaXMgbm90IGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJsdWVza3lBamF4Q2xpZW50Q29uZmlnOiBCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG87XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgZ2V0RmlsZSh1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8RmlsZUNvbnRlbnQ+O1xyXG5cclxuICAgICAgICBidWlsZFVybEZyb21Db250ZXh0KHVybElucHV0OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEJsdWVza3lIdHRwV3JhcHBlciBpbXBsZW1lbnRzIElCbHVlc2t5SHR0cFdyYXBwZXIge1xyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJvcGVydGllc1xyXG5cclxuICAgICAgICBwcml2YXRlIGdldENvbmZpZ1Byb21pc2U6IG5nLklQcm9taXNlPGFueT47XHJcblxyXG4gICAgICAgIHB1YmxpYyBibHVlc2t5QWpheENsaWVudENvbmZpZzogQmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvO1xyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIGN0b3JcclxuXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHByaXZhdGUgXzogVW5kZXJzY29yZVN0YXRpYyxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkaHR0cDogbmcuSUh0dHBTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRxOiBuZy5JUVNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgdG9hc3Rlcjogbmd0b2FzdGVyLklUb2FzdGVyU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBjb25maWdJbml0aWFsaXphdGlvblVSTDogc3RyaW5nLFxyXG4gICAgICAgICAgICBwcml2YXRlIHNlbGVjdGVkVXNlclJvbGU6IFVzZXJSb2xlRW50cnlEdG9cclxuICAgICAgICApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBmZXRjaCB0aGUgY29uZmlndXJhdGlvbiBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBzZXJ2aWNlIHRvIHJ1biBmcm9tIHRoZSBwcm92aWRlZCBlbmRwb2ludFxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb25FbmRwb2ludFVybCA9IHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dChjb25maWdJbml0aWFsaXphdGlvblVSTCwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbkVuZHBvaW50VXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW0luaXRpYWxpemF0aW9uXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSBpbml0aWFsQ29uZmlnIHVybCAnJHtjb25maWdJbml0aWFsaXphdGlvblVSTH0nIHdpdGggZW5kcG9pbnRUeXBlICcke0VuZHBvaW50VHlwZUVudW1bRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluXX0nLiBBYm9ydGluZyBibHVlc2t5SHR0cFNlcnZpY2UgaW5pdC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5nZXRDb25maWdQcm9taXNlID0gdGhpcy4kaHR0cC5nZXQ8Qmx1ZXNreUFqYXhDbGllbnRDb25maWd1cmF0aW9uRHRvPihjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwpXHJcbiAgICAgICAgICAgICAgICAudGhlbjxCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8+KFxyXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgKGNsaWVudENvbmZpZ1Byb21pc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiByZWplY3Qgc3RhdHVzIG5vdCBpbiAyWFggP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgVW5hYmxlIHRvIHJldHJpZXZlIGh0dHAgY29uZmlnIGRhdGEgZnJvbSAnJHtjb25maWdJbml0aWFsaXphdGlvblVSTH0nLiBBYm9ydGluZyBibHVlc2t5SHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0b2FzdGVyID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRDb25maWdQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gZXJyb3JcclxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbjxCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb25EdG8+KFxyXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgKGJsdWVza3lDbGllbnRDb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgY2FzZSB3aGVyZSBjbGllbnQtc2lkZSB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgYW5kIG5vdCA9PSBzcnYtc2lkZSB1c2VyIHJvbGUgIVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmx1ZXNreUNsaWVudENvbmZpZy5jdXJyZW50VXNlclJvbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBub3QgcHJvdmlkZWQgYnkgZG9tYWluIGZyb20gd2hpY2ggY29kZSB3YXMgbG9hZGVkLCB0aGVuIHRyeSB0byBmZXRjaCBkZWZhdWx0IHVzZXJSb2xlIGZyb20gQ0FQSSBlbmRwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQ8VXNlclNzb0R0bz4oJ3VzZXItc3NvP3Byb2ZpbGU9JywgeyBlbmRwb2ludFR5cGU6IEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaSB9KS50aGVuPEJsdWVza3lBamF4Q2xpZW50Q29uZmlndXJhdGlvbkR0bz4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlclNzbykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlclNzbyB8fCAhdXNlclNzby51c2VyUm9sZUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnVW5hYmxlIHRvIHJldHJpZXZlIENvcmVBUEkgZGVmYXVsdCB1c2VyU1NPLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHNlbGVjdGVkVXNlclJvbGUgaXMgYXZhaWxhYmxlIGluIHRoZSBsaXN0IG9mIHVzZXJTU08gcm9sZXMsIG90aGVyd2lzZSBzZWxlY3QgZGVmYXVsdCAhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGluZm9ybSBiYWNrIHRoZSBEQSB0aGF0IHNlbGVjdGVkVXNlclJvbGUgd2FzIHJlc2V0ID8gaW52ZXJ0IHJlc3BvbnNhYmlsaXR5ICYgc3RvcmUgdXNlclJvbGUgaW4gbG9jYWxTdG9yYWdlIGZyb20gdGhpcyBzZXJ2aWNlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclJvbGVUb1VzZSA9IHNlbGVjdGVkVXNlclJvbGUgfHwgdXNlclNzby51c2VyUm9sZUVudHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0aGlzIG5lZWRzIHRvIGJlIHB1dCBpbiBzaGFyZWQgZXh0ZW5zaW9uIG1ldGhvZCAvIHNlcnZpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSA9IHVzZXJSb2xlVG9Vc2UubmFtZSArIFwiIFwiICsgdXNlclJvbGVUb1VzZS5yb2xlICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLnNpbG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY3VycmVudFVzZXIgPSB1c2VyU3NvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB3ZSBvbmx5IGxvYWQgdXNlclNTTyBpZiBubyB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgc3J2LXNpZGUsIHNob3VsZCB3ZSBsb2FkIGl0IGluIGFsbCBjYXNlcyA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRlZmluZWQgdXNlclJvbGUgc2VudCBmcm9tIG9yaWdpbiBhcHAsIHVzZSBpdCAmIHNldCBpdCBhcyBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWxldGU8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLkRFTEVURSwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9zdDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhOztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUFVULCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUT0RPIE1HQTogbm90IERSWSB3aXRoIGFqYXggbWV0aG9kLCBob3cgdG8ga2VlcCBpdCBpbiBzeW5jID9cclxuICAgICAgICAgKiBAcGFyYW0gdXJsXHJcbiAgICAgICAgICogQHBhcmFtIGZpbGVcclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmZpbGUgPSBmaWxlIHx8IGNvbmZpZy5maWxlOyAvL1RPRE8gTUdBIDogZG8gbm90IGV4cG9zZSBmaWxlIGluIElCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcgP1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oKGZpbGVCYXNlNjRVcmwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUZvcm1EYXRhTmFtZSA9ICdmaWxlJzsgLy8gZmlsZSBmb3JtRGF0YSBuYW1lICgnQ29udGVudC1EaXNwb3NpdGlvbicpLCBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGZvcm0gbmFtZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJID8gKGluaXRDYWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGJlaGF2aW9yIGR1cGxpY2F0aW9uIHdpdGggdGhpcy5hamF4LCBub3QgRFJZLCB0byBpbXByb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdENvbmZpZykgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQudXBsb2FkPFQ+KDxuZy5hbmd1bGFyRmlsZVVwbG9hZC5JRmlsZVVwbG9hZENvbmZpZ0ZpbGU+cmVxdWVzdENvbmZpZykgLy9UT0RPIE1HQSA6IG5vdCBzYWZlIGhhcmQgY2FzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW48VD4odGhpcy5vblN1Y2Nlc3M8VD4oY29uZmlnKSwgdGhpcy5vbkVycm9yPFQ+KGNvbmZpZyksIGNvbmZpZy51cGxvYWRQcm9ncmVzcykgLy9UT0RPIE1HQSA6IHVwbG9hZFByb2dyZXNzIGNhbGxiYWNrIG9rID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvL1RPRE8gTUdBOiB3aGF0IHRvIHJldHVybiA/XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkb3dubG9hZCBhIGZpbGUgaW4gdGhlIGZvcm0gb2YgYSBieXRlLXN0cmVhbSBmcm9tIGFuIGVuZHBvaW50IGFuZCB3cmFwIGl0IGludG8gYSBGaWxlQ29udGVudCBvYmplY3Qgd2l0aCBuYW1lLCB0eXBlICYgc2l6ZSBwcm9wZXJ0aWVzIHJlYWQgZnJvbSB0aGUgSFRUUCByZXNwb25zZSBoZWFkZXJzIG9mIHRoZSBzZXJ2ZXVyLlxyXG4gICAgICAgICAqIEl0IGlzIHRoZSByZXNwb25zYWJpbGl0eSBvZiB0aGUgY29uc3VtZXIgdG8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHdyYXBwZWQgYnl0ZUFycmF5IChmb3IgZXhhbXBsZSBkb3dubG9hZCB0aGUgZmlsZSwgb3Igc2hvdyBpdCBpbnNpZGUgdGhlIHdlYlBhZ2UgZXRjKS5cclxuICAgICAgICAgKiBUT0RPIE1HQTogbm90IERSWSB3aXRoIGFqYXggbWV0aG9kLCBob3cgdG8ga2VlcCBpdCBpbiBzeW5jID9cclxuICAgICAgICAgKiBAcGFyYW0gdXJsXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkTmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFNpemVcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEZpbGUodXJsOiBzdHJpbmcsIGNvbmZpZz86IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IG5nLklQcm9taXNlPEZpbGVDb250ZW50PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbigoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbmZpZyByZXR1cm5lZCwgY29uZmlndXJhdGlvbiBmYWlsZWQsIGRvIG5vdCBzdGFydCBhamF4IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIGlmICghYW5ndWxhckh0dHBDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoJ1VuYWJsZSB0byBjb25maWd1cmUgcmVxdWVzdCBjb3JyZWN0bHkuIEFib3J0aW5nIGdldEZpbGUgYWpheCBjYWxsLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYWxseSBleHBlY3QgcmF3IHJlc3BvbnNlIHR5cGUsIG90aGVyd2lzZSBieXRlIHN0cmVhbSByZXNwb25zZXMgYXJlIGNvcnJ1cHRlZC5cclxuICAgICAgICAgICAgICAgIGFuZ3VsYXJIdHRwQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FeHBlY3RlZCBBcnJheUJ1ZmZlciByZXNwb25zZSA9IGJ5dGUgYXJyYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwPEFycmF5QnVmZmVyPihhbmd1bGFySHR0cENvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbjxGaWxlQ29udGVudD4oKGh0dHBSZXNwb25zZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iZW5lZml0IGZyb20gc3VjY2Vzc0NhbGxiYWNrIHZhbGlkYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy5vblN1Y2Nlc3M8QXJyYXlCdWZmZXI+KGNvbmZpZykoaHR0cFJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50OiBGaWxlQ29udGVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmllcyB0byBwYXJzZSB0aGUgaW5wdXQgdXJsIDpcclxuICAgICAgICAgKiBJZiBpdCBzZWVtcyB0byBiZSBhIGZ1bGwgVVJMLCB0aGVuIHJldHVybiBhcyBpcyAoY29uc2lkZXJzIGl0IGV4dGVybmFsIFVybCkgXHJcbiAgICAgICAgICogT3RoZXJ3aXNlLCB0cmllcyB0byBmaW5kIHRoZSBiYXNlIFVSTCBvZiB0aGUgY3VycmVudCBCbHVlU2t5IGFwcCB3aXRoIG9yIHdpdGhvdXQgdGhlIGluY2x1ZGVkIENvbnRyb2xsZXIgYW5kIHJldHVybnMgdGhlIGZ1bGwgVXJsIFxyXG4gICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxyXG4gICAgICAgICAqIEByZXR1cm4gbnVsbCBpZiBub3QgYWJsZSB0byBjb21wdXRlIHVybC4gT3RoZXJ3aXNlLCB1cmwgb2YgdGhlIHJlcXVlc3QgZWl0aGVyIHBhcnRpYWwgb3IgZnVsbCBiYXNlZCBvbiBlbmRwb2ludFR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIGJ1aWxkVXJsRnJvbUNvbnRleHQodXJsSW5wdXQ6IHN0cmluZywgZW5kcG9pbnRUeXBlPzogRW5kcG9pbnRUeXBlRW51bSk6IHN0cmluZyB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ05vIFVSTCBpbnB1dCBwcm92aWRlZC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMsIGV2ZW4gaWYgZW5kcG9pbnRUeXBlIGlzIG5vdCBleHRlcm5hbC5cclxuICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcclxuICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ0Z1bGwgVVJMIHByb3ZpZGVkIGZvciBhIGNhbGwgdGhhdCBpcyBub3QgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJyBlbmRwb2ludFR5cGUsIHRoaXMgaXMgYmFkIHByYWN0aWNlIGFzIG9ubHkgdGhlIGJsdWVza3lXcmFwcGVyIHNob3VsZCBrbm93IGFib3V0IHRoZSBiYXNlVVJMIG9mIHRhcmdldCBlbmRwb2ludHMgKGxvYWRlZCBmcm9tIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudikuIFVzZSBwYXJ0aWFsIFVSTHMuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbHNlLCB3ZSBoYXZlIGEgcGFydGlhbCBVUkwgdG8gY29tcGxldGU6IHVzZSBwcm92aWRlZCBlbmRwb2ludCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gY29tcGxldGUgdXJsLlxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgZW5kcG9pbnRUeXBlIGlmIG5vdCBwcm92aWRlZCBpcyBvcmlnaW4uIFRPRE8gTUdBOiBydWxlIHRvIGRpc2N1c3MsIGhlcmUgZm9yIHJldHJvLWNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgIGVuZHBvaW50VHlwZSA9IGVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybDogc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1BhcnRpYWwgdXJsIHByb3ZpZGVkIGZvciBhIGNhbGwgd2l0aCBlbmRwb2ludFR5cGUgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJzogdGhlIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgcHJvdmlkZWQgdXJsIGlmIGV4dGVybmFsICh3ZSBjYW5ub3Qga25vdyBob3cgdG8gY29tcGxldGUgaXQsIGV2ZW4gaWYgcGFydGlhbCkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gdGhpcy5nZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGVuZHBvaW50VHlwZXM6IGNvbXB1dGUgVVJMIGFzIGEgY29tYmluYXRpb24gb2YgYmFzZVVSTCAmIHN1ZmZpeCBpZiBwcmVzZW50LCBhcyBwcm92aWRlZCBieSBzZXJ2ZXItY29uZmlndXJhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignRXhwZWN0ZWQgZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgcHJvdmlkZWQgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludENvbmZpZyA9IHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbZW5kcG9pbnRUeXBlXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVuZHBvaW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBFbmRwb2ludFR5cGUgJyR7RW5kcG9pbnRUeXBlRW51bVtlbmRwb2ludFR5cGVdfScgaXMgbm90ICdFeHRlcm5hbCcgb3IgJ0N1cnJlbnREb21haW4nLCBleHBlY3RlZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50Q29uZmlndXJhdGlvbiBwcm92aWRlZCBpbiBibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSBidXQgbm9uZSBmb3VuZC4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGVuZHBvaW50Q29uZmlnLmVuZHBvaW50QmFzZVVSTCArIChlbmRwb2ludENvbmZpZy5lbmRwb2ludFN1ZmZpeCB8fCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhvdyB0byBoYW5kbGUgT00gYXBwcyBleHRlcm5hbCBjYWxscyB3aXRob3V0IHNlc3Npb24gcHJvdmlkZWQgPyB3aWxsIHJlc3VsdCBpbiBhIHJlZGlyZWN0IGFuZCBjYWxsIG1heSBmYWlsID9cclxuXHJcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gdXNlZCB0byB0cnkgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgZnVsbCB1cmwgKGFkZCAvIG9yIG5vdCBiZWZvcmUgdGhlIHVybCBmcmFnbWVudCBkZXBlbmRpbmcgb24gaWYgZm91bmQgb3Igbm90KVxyXG4gICAgICAgICAgICB2YXIgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPSB1cmxJbnB1dC5zbGljZSgwLCAxKSA9PT0gJy8nO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCA9IGJhc2VVcmwuc2xpY2UoYmFzZVVybC5sZW5ndGggLSAxLCBiYXNlVXJsLmxlbmd0aCkgPT09ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vYmFzZWQgb24gc3RhcnRpbmcvdHJhaWxpbmcgc2xhc2hlcywgcmV0dXJuIGZ1bGwgdXJsLlxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsYXN0ICcvJyBvbiBiYXNlVXJsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybC5zbGljZSgwLCBiYXNlVXJsLmxlbmd0aCAtIDEpICsgdXJsSW5wdXQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgJy8nICsgdXJsSW5wdXQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkgfHxcclxuICAgICAgICAgICAgICAgICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArIHVybElucHV0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cclxuICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgYWpheDxUPihtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKG1ldGhvZCwgdXJsLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFySHR0cENvbmZpZykgLy8gaWYgbm8gY29uZmlnIHJldHVybmVkLCBjb25maWd1cmF0aW9uIGZhaWxlZCwgZG8gbm90IHN0YXJ0IGFqYXggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwPFQ+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzczxUPihjb25maWcpLCB0aGlzLm9uRXJyb3I8VD4oY29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFByZXBhcmVzIGEge0BsaW5rIG5nIyRodHRwI2NvbmZpZyBjb25maWd9IG9iamVjdCBmb3IgJGh0dHAgY2FsbC5cclxuICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxyXG4gICAgICAgICogIC0gQWpheCBjYWxsc1xyXG4gICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxyXG4gICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS4gICBcclxuICAgICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgICAgKiBAcmV0dXJucyB7bmcuJGh0dHAuY29uZmlnfSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcmVhZHkgdG8gYmUgaW5qZWN0ZWQgaW50byBhICRodHRwIGNhbGwuIFxyXG4gICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBjb25maWd1cmVIdHRwQ2FsbCA9IChtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBCbHVlc2t5SHR0cFJlcXVlc3RDb25maWcpOiBuZy5JUmVxdWVzdENvbmZpZyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBpbnB1dCB2YWxpZGF0aW9uXHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSBmb3IgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgYW5kIGN1c3RvbSBvbmVzIGJhc2VkIG9uIGVuZHBvaW50c1xyXG5cclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSA9IGNvbmZpZy5lbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOyAvLyBkZWZhdWx0IHZhbHVlOiBpZiBub3Qgc3BlY2lmaWVkLCBlbmRwb2ludCB0byB1c2UgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIG9yaWdpbi5cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxyXG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSA8bmcuSVJlcXVlc3RDb25maWc+Y29uZmlnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XHJcblxyXG4gICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBkZWZhdWx0IGNvbmZpZyBmbGFncyBiYXNlZCBvbiB0YXJnZXQgZW5kcG9pbnRcclxuICAgICAgICAgICAgc3dpdGNoIChjb25maWcuZW5kcG9pbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NYXJrZXRpbmdBcGk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2VsZmNhcmVBcGk6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGxpY2l0bHkgd3JvbmcgaW5wdXQgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cud2FybihgW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBBUEkgY2FsbCBpbnRlbmRlZCB3aXRoIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEFib3J0aW5nIGFqYXggY2FsbC5gLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMgZm9yIEFQSSBlbmRwb2ludHMgYXJlIGRpZmZlcmVudCBmcm9tIGRlZmF1bHQsIHNvIHdlIG11c3Qgc3BlY2lmeSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTsgLy8gYnkgZGVmYXVsdCBhbHJlYWR5IGVuYWJsZWQsIGJ1dCBlbmZvcmUgdGhpcyBoZWFkZXIgYXMgbmVjZXNzYXJ5IGZvciBjYWxscyB0byBXZWJBUEkgZW5kcG9pbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSB0cnVlOyAvLyBmb3IgYXBpIGNhbGxzLCBmb3JjZSB0aGlzIHJvbGUgdG8gYmUgcGFzc2VkIGFyb3VuZCAoc2hvdWxkIGJlIG1hbmRhdG9yeSB0byBjb250ZXh0dWFsaXplIHJlcXVlc3QgdG8gcmVhbG0gb2YgY3VycmVudCB1c2VyKS5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5RdW90ZVdpemFyZDpcclxuICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5PcmRlckVudHJ5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyVHJhY2tpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIE9NIGFwcHMgY2FsbGVkIGFzIGVuZHBvaW50cywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogYWRkIGN1cnJlbnRVc2VyUm9sZSBieSBkZWZhdWx0IHNvIHRoYXQgT00gYXBwcyBjYW4gY29udGV4dHVhbGlzZSB0aGUgcmVxdWVzdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWV0cmFuZXQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVjaG5pY2FsSW52ZW50b3J5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlRlbXBsYXRlR2VuZXJhdG9yOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLlNhbGVzZm9yY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm8gc3BlY2lmaWMgY29uZmlnIGZvciB0aG9zZSBleHRlcm5hbCBlbmRwb2ludHMgPyBhZGQgY3VzdG9tIG9uZXMgaWYgbmVlZGVkIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWpheCBjYWxscywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWw6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSB0byBjb25maXJtXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IHRydWU7IC8vIGRvIG5vdCBhZGQgWG1sSHR0cFJlcXVlc3QgaWYgZXh0ZXJuYWwgVXJsIGJ5IGRlZmF1bHQ6IG1pZ2h0IGNyZWF0ZSBjb25mbGljdHMgb24gY2VydGFpbiBzZXJ2ZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXVske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBVbnN1cHBvcnRlZCBlbmRwb2ludFR5cGUgcHJvdmlkZWQ6ICcke0VuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV19Jy4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUmVqZWN0IGFqYXggY2FsbHMgaW50ZW5kZWQgdG8gZXh0ZXJuYWwgZW5kcG9pbnRzIHdpdGhvdXQgbmVjZXNzYXJ5IGNvbmZpZ3VyYXRpb24gbG9hZGVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludFR5cGUgIT09IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbiAmJlxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCAmJlxyXG4gICAgICAgICAgICAgICAgKCF0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbY29uZmlnLmVuZHBvaW50VHlwZV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbJHtjb25maWdGdWxsLm1ldGhvZH0gLyAke3VybH1dIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgZXhwZWN0ZWQgZW5kcG9pbnQgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyIGZvciBlbmRwb2ludFR5cGUgJyR7RW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXX0nLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzZXQgZGVmYXVsdCB2YWx1ZXMgYWZ0ZXIgZW5kcG9pbnQtc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgfHwgZmFsc2U7IC8vIGRlZmF1bHQgdmFsdWUgaXMgZW5hYmxlZCAoYWpheCBjYWxscyBvbiAuTkVUIGVuZHBvaW50cykuXHJcbiAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cclxuICAgICAgICAgICAgY29uZmlnLmRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyA9IGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgfHwgZmFsc2U7IC8vc2V0IGRlZmF1bHQgdmFsdWUgZm9yIGRpc2FibGVUb2FzdGVyTm90aWZpY2F0aW9ucyB0byBmYWxzZSBhcyBpdCdzIHBhcnQgb2YgdGhlIG5vcm1hbCBiZWhhdmlvciBleHBlY3RlZCBmb3IgdGhpcyBzZXJ2aWNlLlxyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGJ1aWxkIGEgdmFsaWQgdXJsIGZyb20gaW5wdXQgJiBlbmRwb2ludFR5cGUuXHJcbiAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgY29uZmlnLmVuZHBvaW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ0Z1bGwudXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSB1cmxJbnB1dCAnJHt1cmx9JyB3aXRoIGVuZHBvaW50VHlwZSAnJHtFbmRwb2ludFR5cGVFbnVtW2NvbmZpZy5lbmRwb2ludFR5cGVdfScuIEFib3J0aW5nIGFqYXggY2FsbC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudXNlQ3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgY2FsbCB3aGVuIG1pc3NpbmcgbWFuZGF0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY3VycmVudFVzZXJSb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gWyR7Y29uZmlnRnVsbC5tZXRob2R9IC8gJHt1cmx9XSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSB1c2VyUm9sZSBzZXQgaW4gY29uZmlnLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydPQS1Vc2VyUm9sZSddID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5jdXJyZW50VXNlclJvbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5kcG9pbnRDb25maWcgPSB0aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnICYmIHRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbY29uZmlnLmVuZHBvaW50VHlwZV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIGF1dGggdG9rZW4gcHJvdmlkZWQgZm9yIHRhcmdldCBlbmRwb2ludCwgYWRkIGl0IGluIGhlYWRlclxyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVuZHBvaW50Q29uZmlnLmF1dGhUb2tlbikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBhdXRoVG9rZW4gZm9yIGVuZHBvaW50cyB0aGF0IGFyZSBub3QgJ3NhZmUnIHRvIHNoYXJlIGF1dGggdG9rZW4gd2l0aCwgc3VjaCBhcyBFeHRlcm5hbCBvbmVzID8gT3IgYXV0aG9yaXplIHRoaXMgc28gdGhhdCBzZXJ2ZXIgY2FuIGxvYWQgYW4gYXV0aCB0b2tlbiBmb3IgY2VydGFpbiBleHRlcm5hbCBlbmRwb2ludHMgP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB0b2tlbiB2YWxpZGl0eSBlbmREYXRlOiByZW5ldyBhdXRoIGJlZm9yZSB0aGUgY2FsbCAhIFdoYXQncyB0aGUgYmVzdCBtb21lbnQgdG8gZG8gaXQgP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVyIHRvIHB1dCBpbiBDT05TVFxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBjdXJyZW50RW5kcG9pbnRDb25maWcuYXV0aFRva2VuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBPRSBzcGVjaWZpYyBjb2RlLCB0byByZW1vdmUsIG9yIGF0IGxlYXN0IHB1dCBpbiBhcyBjb25maWcgcGFyYW1cclxuICAgICAgICAgICAgaWYgKCg8YW55PnRoaXMuJHdpbmRvdykuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XHJcbiAgICAgICAgICAgICAgICAoPGFueT50aGlzLiR3aW5kb3cpLnByZXZlbnRCbG9ja1VJID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb25maWdGdWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyLlxyXG4gICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxyXG4gICAgICAgICAqIElucHV0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICogIC0gY2FsbGluZ0NvbmZpZzogY29uZmlndXJhdGlvbiB1c2VkIHRvIG1ha2UgdGhlIGFqYXggY2FsbCwgaW4gY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBudWxsL2VtcHR5IGFuZCBkb2Vzbid0IGNvbnRhaW4gbmVjZXNzYXJ5IGRhdGEgZm9yIGRlYnVnZ2luZy5cclxuICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIG9uU3VjY2VzcyA9IDxUPihvcmlnaW5hbENvbmZpZzogQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnKTogKGh0dHBQcm9taXNlOiBuZy5JSHR0cFByb21pc2VDYWxsYmFja0FyZzxUPikgPT4gVCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiA8VD4oaHR0cFByb21pc2U6IG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPFQ+KTogVCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbSFRUUCBuby1yZXNwb25zZV0gVW5leHBlY3RlZCAkaHR0cCBlcnJvciwgbm8gcmVzcG9uc2UgcHJvbWlzZSByZXR1cm5lZC5gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignVW5leHBlY3RlZCBiZWhhdmlvcicsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIG11bHRpLXR5cGUgcmV0dXJuIGluIGNhc2Ugb2YgcmVqZWN0aW9uIG9yIGRvIHNvbWV0aGluZyBlbHNlID8gdGhpcyBtZXRob2QgaXMgY3VycmVudGx5IHVzZWQgc3luY2hyb25vdXNseSB3aXRob3V0IHByb21pc2Ugd2FpdGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7IC8vIFJlamVjdCBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGlmIHN0YXR1cyAhPSAyWFggP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXHJcbiAgICAgICAgICAgICAgICAvL2lmICgocHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IG51bGwgfHwgcHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IHVuZGVmaW5lZCkgJiYgcHJvbWlzZUNhbGxiYWNrLnN0YXR1cyAhPT0gMjA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBleHBlY3RlZCByZXNwb25zZSBkYXRhIGJ1dCBub25lIGZvdW5kLicpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QocHJvbWlzZUNhbGxiYWNrKTsgLy8gUmVqZWN0IHByb21pc2UgaWYgbm90IHdlbGwtZm9ybWVkIGRhdGFcclxuICAgICAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5kZWJ1ZyhgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcclxuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUHJvbWlzZS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVycm9yIGhhbmRsZXJcclxuICAgICAgICAgKiBUT0RPIE1HQTogYW5ndWxhciBzaWduYXR1cmVzIGluZGljYXRlcyB0aGF0IHBhcmFtZXRlciBpcyByZWplY3Rpb24gcmVhc29uLCBub3QgbmVjZXNzYXJpbHkgaHR0cFByb21pc2U6IGludmVzdGlnYXRlICYgZml4IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAqIEBwYXJhbSBodHRwUHJvbWlzZSBcclxuICAgICAgICAgKiBAcmV0dXJucyB7fSBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIG9uRXJyb3IgPSA8VD4ob3JpZ2luYWxDb25maWc6IEJsdWVza3lIdHRwUmVxdWVzdENvbmZpZyk6IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55PikgPT4gYW55ID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiA8VD4oaHR0cFByb21pc2U6IG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4pOiBhbnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3VwcG9zZSBpbiBjYXNlIG9mIG5vIHJlc3BvbnNlIHRoYXQgdGhlIHNydiBkaWRuJ3Qgc2VuZCBhbnkgcmVzcG9uc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQTogbWF5IGFsc28gYmUgYSBmYXVsdCBpbiBpbnRlcm5hbCAkaHR0cCAvIGFqYXggY2xpZW50IHNpZGUgbGliLCB0byBkaXN0aW5ndWlzaC5cclxuICAgICAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5kYXRhID0gJ1NlcnZlciBub3QgcmVzcG9uZGluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2Uuc3RhdHVzID0gNTAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGh0dHBQcm9taXNlLmhlYWRlcnMoJ0NvbnRlbnQtVHlwZScpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBjb250ZW50VHlwZSB0byB0cnkgdG8gZGlzcGxheSBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCd0ZXh0L3BsYWluJykgPiAtMSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlOiBzdHJpbmcgPSBcIlwiOyAvL2RlZmF1bHQgbWVzc2FnZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIGVycm9yIGhhbmRsaW5nIG1vcmUgZ2VuZXJpY2FsbHkgYmFzZWQgb24gaW5wdXQgZXJyb3IgbWVzc2FnZSBjb250cmFjdCBpbnN0ZWFkIG9mIGV4cGVjdGluZyBzcGVjaWZpYyBlcnJvciBzdHJjdHVyZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHJlc3BvbnNlLmRhdGEuTW9kZWxTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlICYmIGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIG1vcmUgcmVzcG9uc2UgY29kZXMgZ3JhY2VmdWxseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnTm90IEZvdW5kJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1NlcnZlciByZXNwb25zZSBlcnJvcicsIG1lc3NhZ2UgKyAnXFxuIFN0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJ1N0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZWNvdmVyIGZyb20gZXJyb3IsIHNvIHdlIHByb3BhZ2F0ZSBpdCA6IGJlbG93IGhhbmRsZXJzIGhhdmUgdGhlIGNob2ljZSBvZiByZWFkaW5nIHRoZSBlcnJvciB3aXRoIGFuIGVycm9yIGhhbmRsZXIgb3Igbm90LiBTZWUgJHEgcHJvbWlzZXMgYmVoYXZpb3IgaGVyZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkIHNvIHRoYXQgd2Ugc2hvdyBlcnJvciBpbnNpZGUgc3BlY2lmaWMgc2VydmVyIGNvbW11bmljYXRpb24gbW9kYWxzIGF0IHNwZWNpZmljIHBsYWNlcyBpbiB0aGUgYXBwLCBvdGhlcndpc2Ugc2hvdyBhIGdsb2JhbCBhbGVydCBtZXNzYWdlLCBvciBldmVuIGRvIG5vdCBzaG93IGFueXRoaW5nIGlmIG5vdCBuZWNlc3NhcnkgKGRvIG5vdCBhZCBhbiBlcnJvciBoYW5kbGVyIGluIGJlbG93IGhhbmRsZXJzIG9mIHRoaXMgcHJvbWlzZSkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXHJcbiAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXHJcbiAgICAgICAgICogVE9ETyBNR0EgaW52ZXJzaW9uIG9mIHJlc3BvbnNhYmlsaXR5OiBtYWtlIHRoaXMgZXh0ZW5zaWJsZSBzbyB0aGF0IHNwZWNpZmMgYXBwcyBjYW4gcGx1ZyBpbnRvIHRoaXMgZXZlbnQgd29ya2Zsb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIGZpbmFsbHkgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FLXNwZWNpZmljIGNvZGVcclxuICAgICAgICAgICAgaWYgKCg8YW55PnRoaXMuJHdpbmRvdykuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XHJcbiAgICAgICAgICAgICAgICAoPGFueT50aGlzLiR3aW5kb3cpLnByZXZlbnRCbG9ja1VJID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPIE1HQSA6IHVzaW5nIG1ldGhvZCBmcm9tIExheW91dC5qcyA6IHRvIGRvY3VtZW50IHRvIG5vdCBoYW5kbGUgZHVwbGljYXRlIGNvZGUgISFcclxuICAgICAgICAvL1RPRE8gTUdBOiB1bnJvYnVzdCwgbmVlZHMgc29saWQgcmVmYWN0byB0byBtYWtlIGl0IG1vcmUgZ2VuZXJpYyB3aGVuIG9uIG9yaWdpbiBkb21haW4gIVxyXG4gICAgICAgIHByaXZhdGUgZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXI6IGJvb2xlYW4pOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNSZWdleCA9IC8oXFwvXFx3KylcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLiR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsT21BcHBzTWF0Y2hlcyA9IGJhc2VVcmxPbUFwcHNSZWdleC5leGVjKHVybCk7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsQXNwQXBwc01hdGNoZXMgPSBiYXNlVXJsQXNwQXBwc1JlZ2V4LmV4ZWModXJsKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lOiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybDogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIDIgbWF0Y2hlcyA9IHJlZ2V4IG1hdGNoZXMgKyB0aGUgY2FwdHVyaW5nIGdyb3VwXHJcbiAgICAgICAgICAgIGlmIChiYXNlVXJsT21BcHBzTWF0Y2hlcyAmJiBiYXNlVXJsT21BcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybEFzcEFwcHNNYXRjaGVzICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgJiYgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFzZVVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcclxuICAgICAgICBwcml2YXRlIGdldEN1cnJlbnRTZXNzaW9uSUQoKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcclxuICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcbiAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVwZGF0ZSByZWdleHAgdG8gdGhlIG9uZSBiZWxvd1xyXG4gICAgICAgICAgICAvL3ZhciBiYXNlVXJsUmVnZXggPSAvKGh0dHBzOlxcL1xcL1tcXHcuLV0rXFwvW1xcdy4tXStcXC9cXChTXFwoXFx3K1xcKVxcKVxcLylcXHcrLztcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2V4cEFycmF5ID0gc2Vzc2lvblJlZ2V4LmV4ZWMocGF0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVG9vIG1hbnkgbWF0Y2hlcyBmb3VuZCBmb3IgdGhlIHNlc3Npb25JRCBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgdXJsLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmltIHRoZSBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciB0byByZXR1cm4gb25seSB0aGUgZmlsZW5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgaWYgKCFjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIlxuXG5cblxudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIHNlcnZpY2VzO1xuICAgICAgICAoZnVuY3Rpb24gKHNlcnZpY2VzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3ZpZGVyIGZvciB0aGUgQmx1ZXNreUh0dHBXcmFwcGVyLlxuICAgICAgICAgICAgICogRW5hYmxlcyBwZXItY29uc3VtZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgaHR0cCBzZXJ2aWNlIHRvIHNldCBjdXN0b20gY29uZmlndXJhdGlvbiBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tOlxuICAgICAgICAgICAgICogIC0gQ2xpZW50IGluaXRpYWwgY29uZmlndXJhdGlvbiBVUkwgZnJvbSB0aGUgb3JpZ2luIHRoZSBhcHAgd2FzIGxvYWRlZCBmcm9tLlxuICAgICAgICAgICAgICogIC0gVXNlclJvbGUgdG8gdXNlIG9mIGFscmVhZHkgZmV0Y2hlZCBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCA9ICdCbHVlc2t5QWpheENsaWVudENvbmZpZ3VyYXRpb24vR2V0QWpheENsaWVudENvbmZpZ3VyYXRpb24nOyAvLyBieSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVXNlclJvbGUgPSBudWxsOyAvLyBieSBkZWZhdWx0IG5vdC1zZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aWRlcidzIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uIChfLCAkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNlcnZpY2VzLkJsdWVza3lIdHRwV3JhcHBlcihfLCAkaHR0cCwgJHdpbmRvdywgJGxvZywgJHEsICRsb2NhdGlvbiwgVXBsb2FkLCB0b2FzdGVyLCBfdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybCwgX3RoaXMuc2VsZWN0ZWRVc2VyUm9sZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgY29uZmlndXJhdGlvbiBtZXRob2RzXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIucHJvdG90eXBlLnNldENsaWVudENvbmZpZ1VSTCA9IGZ1bmN0aW9uIChjbGllbnRDb25maWdVcmxUb1VzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENsaWVudENvbmZpZ0luaXRpYWxpemF0aW9uVXJsID0gY2xpZW50Q29uZmlnVXJsVG9Vc2UgfHwgdGhpcy5nZXRDbGllbnRDb25maWdJbml0aWFsaXphdGlvblVybDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlclByb3ZpZGVyLnByb3RvdHlwZS5zZXRVc2VyUm9sZVRvVXNlID0gZnVuY3Rpb24gKHVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSA9IHVzZXJSb2xlIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXI7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgc2VydmljZXMuQmx1ZXNreUh0dHBXcmFwcGVyUHJvdmlkZXIgPSBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcjtcbiAgICAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCdibHVlc2t5Lmh0dHBXcmFwcGVyJywgWyd0b2FzdGVyJywgJ25nQW5pbWF0ZScsICduZ0ZpbGVVcGxvYWQnXSlcbiAgICAgICAgICAgICAgICAuY29uc3RhbnQoJ18nLCB3aW5kb3cuXylcbiAgICAgICAgICAgICAgICAuY29uc3RhbnQoJ21vbWVudCcsIHdpbmRvdy5tb21lbnQpXG4gICAgICAgICAgICAgICAgLnByb3ZpZGVyKCdibHVlc2t5SHR0cFdyYXBwZXInLCBCbHVlc2t5SHR0cFdyYXBwZXJQcm92aWRlcik7XG4gICAgICAgIH0pKHNlcnZpY2VzID0gY29yZS5zZXJ2aWNlcyB8fCAoY29yZS5zZXJ2aWNlcyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZXM7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZXMpIHtcbiAgICAgICAgICAgIHZhciBFbmRwb2ludFR5cGVFbnVtID0gYmx1ZXNreS5jb3JlLm1vZGVscy5jbGllbnRDb25maWcuRW5kcG9pbnRUeXBlRW51bTtcbiAgICAgICAgICAgIHZhciBIdHRwTWV0aG9kO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChIdHRwTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiR0VUXCJdID0gMF0gPSBcIkdFVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBPU1RcIl0gPSAxXSA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBVVFwiXSA9IDJdID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJERUxFVEVcIl0gPSAzXSA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICB9KShIdHRwTWV0aG9kIHx8IChIdHRwTWV0aG9kID0ge30pKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBCbHVlc2t5SHR0cFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBjdG9yXG4gICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmx1ZXNreUh0dHBXcmFwcGVyKF8sICRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIsIGNvbmZpZ0luaXRpYWxpemF0aW9uVVJMLCBzZWxlY3RlZFVzZXJSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDEgLSBmZXRjaCB0aGUgY29uZmlndXJhdGlvbiBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBzZXJ2aWNlIHRvIHJ1biBmcm9tIHRoZSBwcm92aWRlZCBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8gPSBfO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRodHRwID0gJGh0dHA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpbmRvdyA9ICR3aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZyA9ICRsb2c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHEgPSAkcTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVXBsb2FkID0gVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIgPSB0b2FzdGVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ0luaXRpYWxpemF0aW9uVVJMID0gY29uZmlnSW5pdGlhbGl6YXRpb25VUkw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRVc2VyUm9sZSA9IHNlbGVjdGVkVXNlclJvbGU7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAqIFByZXBhcmVzIGEge0BsaW5rIG5nIyRodHRwI2NvbmZpZyBjb25maWd9IG9iamVjdCBmb3IgJGh0dHAgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgKiBUaGUgb3BlcmF0aW9ucyBpbmNsdWRlIHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgd2hlbiBub3QgcHJvdmlkZWQsIGFuZCBzZXR0aW5nIGh0dHAgaGVhZGVycyBpZiBuZWVkZWQgZm9yIDpcbiAgICAgICAgICAgICAgICAgICAgKiAgLSBBamF4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAqICAtIEN1cnJlbnQgVXNlclJvbGUuXG4gICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bmcuJGh0dHAuY29uZmlnfSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcmVhZHkgdG8gYmUgaW5qZWN0ZWQgaW50byBhICRodHRwIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlSHR0cENhbGwgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5wdXQgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmwgfHwgbWV0aG9kID09PSBudWxsIHx8IG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSBmb3IgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgY29uZmlnIHZhbHVlcyBhbmQgY3VzdG9tIG9uZXMgYmFzZWQgb24gZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZW5kcG9pbnRUeXBlID0gY29uZmlnLmVuZHBvaW50VHlwZSB8fCBFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW47IC8vIGRlZmF1bHQgdmFsdWU6IGlmIG5vdCBzcGVjaWZpZWQsIGVuZHBvaW50IHRvIHVzZSBpcyBzdXBwb3NlZCB0byBiZSB0aGUgb3JpZ2luLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjYXN0IGlzIG5vdCBzYWZlLCB3ZSBtYXkgZm9yZ2V0IHRvIHNldCB1cmwgJiBtZXRob2QgcGFyYW1ldGVycy4gVE9GSVguXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWdGdWxsID0gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwubWV0aG9kID0gSHR0cE1ldGhvZFttZXRob2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWd1cmUgZGVmYXVsdCBjb25maWcgZmxhZ3MgYmFzZWQgb24gdGFyZ2V0IGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZy5lbmRwb2ludFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uQ29yZUFwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uTWFya2V0aW5nQXBpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5TZWxmY2FyZUFwaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGxpY2l0bHkgd3JvbmcgaW5wdXQgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cud2FybihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBBUEkgY2FsbCBpbnRlbmRlZCB3aXRoIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEFib3J0aW5nIGFqYXggY2FsbC5cIiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMgZm9yIEFQSSBlbmRwb2ludHMgYXJlIGRpZmZlcmVudCBmcm9tIGRlZmF1bHQsIHNvIHdlIG11c3Qgc3BlY2lmeSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gZmFsc2U7IC8vIGJ5IGRlZmF1bHQgYWxyZWFkeSBlbmFibGVkLCBidXQgZW5mb3JlIHRoaXMgaGVhZGVyIGFzIG5lY2Vzc2FyeSBmb3IgY2FsbHMgdG8gV2ViQVBJIGVuZHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSA9IHRydWU7IC8vIGZvciBhcGkgY2FsbHMsIGZvcmNlIHRoaXMgcm9sZSB0byBiZSBwYXNzZWQgYXJvdW5kIChzaG91bGQgYmUgbWFuZGF0b3J5IHRvIGNvbnRleHR1YWxpemUgcmVxdWVzdCB0byByZWFsbSBvZiBjdXJyZW50IHVzZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uUXVvdGVXaXphcmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyRW50cnk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbmRwb2ludFR5cGVFbnVtLk9yZGVyVHJhY2tpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBPTSBhcHBzIGNhbGxlZCBhcyBlbmRwb2ludHMsIG1ha2Ugc3VyZSB0aGUgWG1sSHR0cFJlcXVlc3QgaGVhZGVyIGlzIHByZXNlbnQgKEFTUC5ORVQgYXBwcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogYWRkIGN1cnJlbnRVc2VyUm9sZSBieSBkZWZhdWx0IHNvIHRoYXQgT00gYXBwcyBjYW4gY29udGV4dHVhbGlzZSB0aGUgcmVxdWVzdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5NZXRyYW5ldDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uVGVjaG5pY2FsSW52ZW50b3J5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5UZW1wbGF0ZUdlbmVyYXRvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uU2FsZXNmb3JjZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbm8gc3BlY2lmaWMgY29uZmlnIGZvciB0aG9zZSBleHRlcm5hbCBlbmRwb2ludHMgPyBhZGQgY3VzdG9tIG9uZXMgaWYgbmVlZGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWpheCBjYWxscywgbWFrZSBzdXJlIHRoZSBYbWxIdHRwUmVxdWVzdCBoZWFkZXIgaXMgcHJlc2VudCAoQVNQLk5FVCBhcHBzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVuZHBvaW50VHlwZUVudW0uRXh0ZXJuYWw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgdG8gY29uZmlybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gdHJ1ZTsgLy8gZG8gbm90IGFkZCBYbWxIdHRwUmVxdWVzdCBpZiBleHRlcm5hbCBVcmwgYnkgZGVmYXVsdDogbWlnaHQgY3JlYXRlIGNvbmZsaWN0cyBvbiBjZXJ0YWluIHNlcnZlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF1bXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBVbnN1cHBvcnRlZCBlbmRwb2ludFR5cGUgcHJvdmlkZWQ6ICdcIiArIEVuZHBvaW50VHlwZUVudW1bY29uZmlnLmVuZHBvaW50VHlwZV0gKyBcIicuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JlamVjdCBhamF4IGNhbGxzIGludGVuZGVkIHRvIGV4dGVybmFsIGVuZHBvaW50cyB3aXRob3V0IG5lY2Vzc2FyeSBjb25maWd1cmF0aW9uIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVuZHBvaW50VHlwZSAhPT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmVuZHBvaW50Q29uZmlndXJhdGlvbkRpY3Rpb25uYXJ5W2NvbmZpZy5lbmRwb2ludFR5cGVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtjb25maWd1cmVIdHRwQ2FsbF0gW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gQWpheCBjYWxsIGludGVuZGVkIHdpdGhvdXQgZXhwZWN0ZWQgZW5kcG9pbnQgY29uZmlndXJhdGlvbiBsb2FkZWQgZnJvbSB0aGUgc2VydmVyIGZvciBlbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXSArIFwiJy4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2V0IGRlZmF1bHQgdmFsdWVzIGFmdGVyIGVuZHBvaW50LXNwZWNpZmljIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyID0gY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlciB8fCBmYWxzZTsgLy8gZGVmYXVsdCB2YWx1ZSBpcyBlbmFibGVkIChhamF4IGNhbGxzIG9uIC5ORVQgZW5kcG9pbnRzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy51c2VDdXJyZW50VXNlclJvbGUgPSBjb25maWcudXNlQ3VycmVudFVzZXJSb2xlIHx8IGZhbHNlOyAvLyBkZWZhdWx0IHZhbHVlOiBkb24ndCB0cmFuc21pdCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdG8gcmVtb3RlIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgPSBjb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zIHx8IGZhbHNlOyAvL3NldCBkZWZhdWx0IHZhbHVlIGZvciBkaXNhYmxlVG9hc3Rlck5vdGlmaWNhdGlvbnMgdG8gZmFsc2UgYXMgaXQncyBwYXJ0IG9mIHRoZSBub3JtYWwgYmVoYXZpb3IgZXhwZWN0ZWQgZm9yIHRoaXMgc2VydmljZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBidWlsZCBhIHZhbGlkIHVybCBmcm9tIGlucHV0ICYgZW5kcG9pbnRUeXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSBfdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCwgY29uZmlnLmVuZHBvaW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZ0Z1bGwudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltCbHVlc2t5SHR0cFdyYXBwZXJdW2NvbmZpZ3VyZUh0dHBDYWxsXSAtIFVuYWJsZSB0byBidWlsZCB1cmwgZnJvbSB1cmxJbnB1dCAnXCIgKyB1cmwgKyBcIicgd2l0aCBlbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtjb25maWcuZW5kcG9pbnRUeXBlXSArIFwiJy4gQWJvcnRpbmcgYWpheCBjYWxsLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnVzZUN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBjYWxsIHdoZW4gbWlzc2luZyBtYW5kYXRvcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0JsdWVza3lIdHRwV3JhcHBlcl1bY29uZmlndXJlSHR0cENhbGxdIFtcIiArIGNvbmZpZ0Z1bGwubWV0aG9kICsgXCIgLyBcIiArIHVybCArIFwiXSAtIEFqYXggY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSB1c2VyUm9sZSBzZXQgaW4gY29uZmlnLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlciB0byBwdXQgaW4gQ09OU1RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSBfdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5jdXJyZW50VXNlclJvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEVuZHBvaW50Q29uZmlnID0gX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgJiYgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnlbY29uZmlnLmVuZHBvaW50VHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoIHRva2VuIHByb3ZpZGVkIGZvciB0YXJnZXQgZW5kcG9pbnQsIGFkZCBpdCBpbiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RW5kcG9pbnRDb25maWcuYXV0aFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogcmVqZWN0IGF1dGhUb2tlbiBmb3IgZW5kcG9pbnRzIHRoYXQgYXJlIG5vdCAnc2FmZScgdG8gc2hhcmUgYXV0aCB0b2tlbiB3aXRoLCBzdWNoIGFzIEV4dGVybmFsIG9uZXMgPyBPciBhdXRob3JpemUgdGhpcyBzbyB0aGF0IHNlcnZlciBjYW4gbG9hZCBhbiBhdXRoIHRva2VuIGZvciBjZXJ0YWluIGV4dGVybmFsIGVuZHBvaW50cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHRva2VuIHZhbGlkaXR5IGVuZERhdGU6IHJlbmV3IGF1dGggYmVmb3JlIHRoZSBjYWxsICEgV2hhdCdzIHRoZSBiZXN0IG1vbWVudCB0byBkbyBpdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXIgdG8gcHV0IGluIENPTlNUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBjdXJyZW50RW5kcG9pbnRDb25maWcuYXV0aFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Ugc3BlY2lmaWMgY29kZSwgdG8gcmVtb3ZlLCBvciBhdCBsZWFzdCBwdXQgaW4gYXMgY29uZmlnIHBhcmFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHdpbmRvdy5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHdpbmRvdy5wcmV2ZW50QmxvY2tVSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnRnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgICAgICogQ2FwdHVyZXMgdGhlIGlucHV0IHBhcmFtZXRlcnMgYXQgdGhlIG1vbWVudCBvZiBpdHMgZGVjbGFyYXRpb24gJiByZXR1cm4gdGhlIHJlYWwgaGFuZGxlciB0byBiZSBjYWxsZWQgdXBvbiBwcm9taXNlIGNvbXBsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIElucHV0IHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgICAgICAgICAqICAtIGNhbGxpbmdDb25maWc6IGNvbmZpZ3VyYXRpb24gdXNlZCB0byBtYWtlIHRoZSBhamF4IGNhbGwsIGluIGNhc2UgdGhlIHJldHVybmVkIHByb21pc2UgaXMgbnVsbC9lbXB0eSBhbmQgZG9lc24ndCBjb250YWluIG5lY2Vzc2FyeSBkYXRhIGZvciBkZWJ1Z2dpbmcuXG4gICAgICAgICAgICAgICAgICAgICAqICAtIGdldENvbXBsZXRlUmVzcG9uc2VPYmplY3Q6IGZsYWcgaW5kaWNhdGlvbiBpZiB3ZSBtdXN0IHJldHVybiB0aGUgZnVsbCByZXNwb25zZSBvYmplY3QgYWxvbmcgd2l0aCBoZWFkZXJzIGFuZCBzdGF0dXMgb3Igb25seSB0aGUgaW5uZXIgZGF0YS4gQnkgZGVmYXVsdCAmIGlmIG5vdCBzcGVjaWZpZWQsIG9ubHkgcmV0dXJucyBpbm5lciBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBuby1yZXNwb25zZV0gVW5leHBlY3RlZCAkaHR0cCBlcnJvciwgbm8gcmVzcG9uc2UgcHJvbWlzZSByZXR1cm5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignVW5leHBlY3RlZCBiZWhhdmlvcicsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBpZiBzdGF0dXMgIT0gMlhYID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgd2hlbiBBUEkgaXMgZml4ZWQuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExNzQ2ODk0L3doYXQtaXMtdGhlLXByb3Blci1yZXN0LXJlc3BvbnNlLWNvZGUtZm9yLWEtdmFsaWQtcmVxdWVzdC1idXQtYW4tZW1wdHktZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKChwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gbnVsbCB8fCBwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gdW5kZWZpbmVkKSAmJiBwcm9taXNlQ2FsbGJhY2suc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBleHBlY3RlZCByZXNwb25zZSBkYXRhIGJ1dCBub25lIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdVbmV4cGVjdGVkIHJlc3BvbnNlJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChwcm9taXNlQ2FsbGJhY2spOyAvLyBSZWplY3QgcHJvbWlzZSBpZiBub3Qgd2VsbC1mb3JtZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNhbWUgYmVoYXZpb3IgYWxzbyBvbiBhIEdFVCByZXF1ZXN0ID8gaWYgcmVxdWVzdCBpcyBHRVQgYW5kIHJlc3BvbnNlIGlzIDIwMCB3aXRoIG5vIGRhdGEsIHJldHVybiBlcnJvciA/IChwYXNzIGluIHBhcmFtZXRlciByZXF1ZXN0IGNvbnRleHQgdG8gbG9nIHRoaXMgZXJyb3IpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5kZWJ1ZyhcIltIVFRQIFwiICsgaHR0cFByb21pc2UuY29uZmlnLm1ldGhvZCArIFwiXSBbXCIgKyBodHRwUHJvbWlzZS5jb25maWcudXJsICsgXCJdXCIsIGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gb25seSB0aGUgZGF0YSBleHBlY3RlZCBmb3IgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgKiBUT0RPIE1HQTogYW5ndWxhciBzaWduYXR1cmVzIGluZGljYXRlcyB0aGF0IHBhcmFtZXRlciBpcyByZWplY3Rpb24gcmVhc29uLCBub3QgbmVjZXNzYXJpbHkgaHR0cFByb21pc2U6IGludmVzdGlnYXRlICYgZml4IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge31cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uIChvcmlnaW5hbENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHN1cHBvc2UgaW4gY2FzZSBvZiBubyByZXNwb25zZSB0aGF0IHRoZSBzcnYgZGlkbid0IHNlbmQgYW55IHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYXkgYWxzbyBiZSBhIGZhdWx0IGluIGludGVybmFsICRodHRwIC8gYWpheCBjbGllbnQgc2lkZSBsaWIsIHRvIGRpc3Rpbmd1aXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YSA9ICdTZXJ2ZXIgbm90IHJlc3BvbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5zdGF0dXMgPSA1MDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxDb25maWcuZGlzYWJsZVRvYXN0ZXJOb3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGh0dHBQcm9taXNlLmhlYWRlcnMoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGNvbnRlbnRUeXBlIHRvIHRyeSB0byBkaXNwbGF5IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCd0ZXh0L3BsYWluJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjsgLy9kZWZhdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChyZXNwb25zZS5kYXRhLk1vZGVsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC8vVE9ETyBNR0EgOiBoYW5kbGUgdGhpcyB3aGVuIHdlbGwgZm9ybWF0dGVkIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSAmJiBhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIG1vcmUgcmVzcG9uc2UgY29kZXMgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIud2FybmluZygnTm90IEZvdW5kJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdTZXJ2ZXIgcmVzcG9uc2UgZXJyb3InLCBtZXNzYWdlICsgJ1xcbiBTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJ1N0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0hUVFAgXCIgKyBodHRwUHJvbWlzZS5jb25maWcubWV0aG9kICsgXCJdIFtcIiArIGh0dHBQcm9taXNlLmNvbmZpZy51cmwgKyBcIl1cIiwgaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlY292ZXIgZnJvbSBlcnJvciwgc28gd2UgcHJvcGFnYXRlIGl0IDogYmVsb3cgaGFuZGxlcnMgaGF2ZSB0aGUgY2hvaWNlIG9mIHJlYWRpbmcgdGhlIGVycm9yIHdpdGggYW4gZXJyb3IgaGFuZGxlciBvciBub3QuIFNlZSAkcSBwcm9taXNlcyBiZWhhdmlvciBoZXJlIDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkIHNvIHRoYXQgd2Ugc2hvdyBlcnJvciBpbnNpZGUgc3BlY2lmaWMgc2VydmVyIGNvbW11bmljYXRpb24gbW9kYWxzIGF0IHNwZWNpZmljIHBsYWNlcyBpbiB0aGUgYXBwLCBvdGhlcndpc2Ugc2hvdyBhIGdsb2JhbCBhbGVydCBtZXNzYWdlLCBvciBldmVuIGRvIG5vdCBzaG93IGFueXRoaW5nIGlmIG5vdCBuZWNlc3NhcnkgKGRvIG5vdCBhZCBhbiBlcnJvciBoYW5kbGVyIGluIGJlbG93IGhhbmRsZXJzIG9mIHRoaXMgcHJvbWlzZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYWpheCBjYWxsLCByZWdhcmRsZXNzIG9mIGl0J3Mgc3VjY2VzcyBvciBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICogVE9ETyBNR0EgaW52ZXJzaW9uIG9mIHJlc3BvbnNhYmlsaXR5OiBtYWtlIHRoaXMgZXh0ZW5zaWJsZSBzbyB0aGF0IHNwZWNpZmMgYXBwcyBjYW4gcGx1ZyBpbnRvIHRoaXMgZXZlbnQgd29ya2Zsb3dcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FLXNwZWNpZmljIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kd2luZG93LmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maWd1cmF0aW9uRW5kcG9pbnRVcmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQoY29uZmlnSW5pdGlhbGl6YXRpb25VUkwsIEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbkVuZHBvaW50VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoXCJbQmx1ZXNreUh0dHBXcmFwcGVyXVtJbml0aWFsaXphdGlvbl0gLSBVbmFibGUgdG8gYnVpbGQgdXJsIGZyb20gaW5pdGlhbENvbmZpZyB1cmwgJ1wiICsgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwgKyBcIicgd2l0aCBlbmRwb2ludFR5cGUgJ1wiICsgRW5kcG9pbnRUeXBlRW51bVtFbmRwb2ludFR5cGVFbnVtLkN1cnJlbnREb21haW5dICsgXCInLiBBYm9ydGluZyBibHVlc2t5SHR0cFNlcnZpY2UgaW5pdC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDb25maWdQcm9taXNlID0gdGhpcy4kaHR0cC5nZXQoY29uZmlndXJhdGlvbkVuZHBvaW50VXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNsaWVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHJlamVjdCBzdGF0dXMgbm90IGluIDJYWCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaWVudENvbmZpZ1Byb21pc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlVuYWJsZSB0byByZXRyaWV2ZSBodHRwIGNvbmZpZyBkYXRhIGZyb20gJ1wiICsgY29uZmlnSW5pdGlhbGl6YXRpb25VUkwgKyBcIicuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHRvYXN0ZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsdWVza3lBamF4Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlnUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudENvbmZpZ1Byb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGJsdWVza3lIdHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChibHVlc2t5Q2xpZW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgY2FzZSB3aGVyZSBjbGllbnQtc2lkZSB1c2VyUm9sZSB3YXMgcHJvdmlkZWQgYW5kIG5vdCA9PSBzcnYtc2lkZSB1c2VyIHJvbGUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibHVlc2t5Q2xpZW50Q29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgbm90IHByb3ZpZGVkIGJ5IGRvbWFpbiBmcm9tIHdoaWNoIGNvZGUgd2FzIGxvYWRlZCwgdGhlbiB0cnkgdG8gZmV0Y2ggZGVmYXVsdCB1c2VyUm9sZSBmcm9tIENBUEkgZW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KCd1c2VyLXNzbz9wcm9maWxlPScsIHsgZW5kcG9pbnRUeXBlOiBFbmRwb2ludFR5cGVFbnVtLkNvcmVBcGkgfSkudGhlbihmdW5jdGlvbiAodXNlclNzbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJTc28gfHwgIXVzZXJTc28udXNlclJvbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmFibGUgdG8gcmV0cmlldmUgQ29yZUFQSSBkZWZhdWx0IHVzZXJTU08uIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSBzZWxlY3RlZFVzZXJSb2xlIGlzIGF2YWlsYWJsZSBpbiB0aGUgbGlzdCBvZiB1c2VyU1NPIHJvbGVzLCBvdGhlcndpc2Ugc2VsZWN0IGRlZmF1bHQgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBob3cgdG8gaW5mb3JtIGJhY2sgdGhlIERBIHRoYXQgc2VsZWN0ZWRVc2VyUm9sZSB3YXMgcmVzZXQgPyBpbnZlcnQgcmVzcG9uc2FiaWxpdHkgJiBzdG9yZSB1c2VyUm9sZSBpbiBsb2NhbFN0b3JhZ2UgZnJvbSB0aGlzIHNlcnZpY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclJvbGVUb1VzZSA9IHNlbGVjdGVkVXNlclJvbGUgfHwgdXNlclNzby51c2VyUm9sZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB0aGlzIG5lZWRzIHRvIGJlIHB1dCBpbiBzaGFyZWQgZXh0ZW5zaW9uIG1ldGhvZCAvIHNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY3VycmVudFVzZXJSb2xlID0gdXNlclJvbGVUb1VzZS5uYW1lICsgXCIgXCIgKyB1c2VyUm9sZVRvVXNlLnJvbGUgKyBcIiBcIiArIHVzZXJSb2xlVG9Vc2Uuc2lsbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcuY3VycmVudFVzZXIgPSB1c2VyU3NvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZXNreUNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHdlIG9ubHkgbG9hZCB1c2VyU1NPIGlmIG5vIHVzZXJSb2xlIHdhcyBwcm92aWRlZCBzcnYtc2lkZSwgc2hvdWxkIHdlIGxvYWQgaXQgaW4gYWxsIGNhc2VzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRlZmluZWQgdXNlclJvbGUgc2VudCBmcm9tIG9yaWdpbiBhcHAsIHVzZSBpdCAmIHNldCBpdCBhcyBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHVlc2t5Q2xpZW50Q29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkRFTEVURSwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBVVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBmaWxlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHVybCwgZmlsZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5maWxlID0gZmlsZSB8fCBjb25maWcuZmlsZTsgLy9UT0RPIE1HQSA6IGRvIG5vdCBleHBvc2UgZmlsZSBpbiBJQmx1ZXNreUh0dHBSZXF1ZXN0Q29uZmlnID9cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGZpbGVCYXNlNjRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVGb3JtRGF0YU5hbWUgPSAnZmlsZSc7IC8vIGZpbGUgZm9ybURhdGEgbmFtZSAoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKSwgc2VydmVyIHNpZGUgcmVxdWVzdCBmb3JtIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJID8gKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdENvbmZpZyA9IF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Q29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuVXBsb2FkLnVwbG9hZChyZXF1ZXN0Q29uZmlnKSAvL1RPRE8gTUdBIDogbm90IHNhZmUgaGFyZCBjYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihfdGhpcy5vblN1Y2Nlc3MoY29uZmlnKSwgX3RoaXMub25FcnJvcihjb25maWcpLCBjb25maWcudXBsb2FkUHJvZ3Jlc3MpIC8vVE9ETyBNR0EgOiB1cGxvYWRQcm9ncmVzcyBjYWxsYmFjayBvayA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9UT0RPIE1HQTogd2hhdCB0byByZXR1cm4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cbiAgICAgICAgICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXG4gICAgICAgICAgICAgICAgICogVE9ETyBNR0E6IG5vdCBEUlkgd2l0aCBhamF4IG1ldGhvZCwgaG93IHRvIGtlZXAgaXQgaW4gc3luYyA/XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEZpbGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjb25maWcgcmV0dXJuZWQsIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBkbyBub3Qgc3RhcnQgYWpheCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXJIdHRwQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdCgnVW5hYmxlIHRvIGNvbmZpZ3VyZSByZXF1ZXN0IGNvcnJlY3RseS4gQWJvcnRpbmcgZ2V0RmlsZSBhamF4IGNhbGwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZXhwZWN0IHJhdyByZXNwb25zZSB0eXBlLCBvdGhlcndpc2UgYnl0ZSBzdHJlYW0gcmVzcG9uc2VzIGFyZSBjb3JydXB0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFySHR0cENvbmZpZy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9FeHBlY3RlZCBBcnJheUJ1ZmZlciByZXNwb25zZSA9IGJ5dGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kaHR0cChhbmd1bGFySHR0cENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iZW5lZml0IGZyb20gc3VjY2Vzc0NhbGxiYWNrIHZhbGlkYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSBfdGhpcy5vblN1Y2Nlc3MoY29uZmlnKShodHRwUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmdldEZpbGVOYW1lRnJvbUhlYWRlckNvbnRlbnREaXNwb3NpdGlvbihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1kaXNwb3NpdGlvbicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LXR5cGUnKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLm9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVHJpZXMgdG8gcGFyc2UgdGhlIGlucHV0IHVybCA6XG4gICAgICAgICAgICAgICAgICogSWYgaXQgc2VlbXMgdG8gYmUgYSBmdWxsIFVSTCwgdGhlbiByZXR1cm4gYXMgaXMgKGNvbnNpZGVycyBpdCBleHRlcm5hbCBVcmwpXG4gICAgICAgICAgICAgICAgICogT3RoZXJ3aXNlLCB0cmllcyB0byBmaW5kIHRoZSBiYXNlIFVSTCBvZiB0aGUgY3VycmVudCBCbHVlU2t5IGFwcCB3aXRoIG9yIHdpdGhvdXQgdGhlIGluY2x1ZGVkIENvbnRyb2xsZXIgYW5kIHJldHVybnMgdGhlIGZ1bGwgVXJsXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVybElucHV0IDogVE9ETyBNR0E6IGRvY3VtZW50IGRpZmZlcmVudCBraW5kIG9mIHVybHMgdGhhdCB0aGlzIG1ldGhvZCBjYW4gdGFrZSBhcyBpbnB1dCAoZnVsbCwgcGFydGlhbCBldGMpXG4gICAgICAgICAgICAgICAgICogQHJldHVybiBudWxsIGlmIG5vdCBhYmxlIHRvIGNvbXB1dGUgdXJsLiBPdGhlcndpc2UsIHVybCBvZiB0aGUgcmVxdWVzdCBlaXRoZXIgcGFydGlhbCBvciBmdWxsIGJhc2VkIG9uIGVuZHBvaW50VHlwZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmJ1aWxkVXJsRnJvbUNvbnRleHQgPSBmdW5jdGlvbiAodXJsSW5wdXQsIGVuZHBvaW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVybElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ05vIFVSTCBpbnB1dCBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIFVybCBzdGFydHMgd2l0aCBodHRwOi8vIG9yIGh0dHBzOi8vID0+IHJldHVybiBhcyBpcywgZXZlbiBpZiBlbmRwb2ludFR5cGUgaXMgbm90IGV4dGVybmFsLlxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHA6Ly8nLmxlbmd0aCkgPT09ICdodHRwOi8vJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHBzOi8vJy5sZW5ndGgpID09PSAnaHR0cHM6Ly8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRUeXBlICE9PSBFbmRwb2ludFR5cGVFbnVtLkV4dGVybmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy53YXJuKCdGdWxsIFVSTCBwcm92aWRlZCBmb3IgYSBjYWxsIHRoYXQgaXMgbm90IGZsYWdnZWQgYXMgXFwnRXh0ZXJuYWxcXCcgZW5kcG9pbnRUeXBlLCB0aGlzIGlzIGJhZCBwcmFjdGljZSBhcyBvbmx5IHRoZSBibHVlc2t5V3JhcHBlciBzaG91bGQga25vdyBhYm91dCB0aGUgYmFzZVVSTCBvZiB0YXJnZXQgZW5kcG9pbnRzIChsb2FkZWQgZnJvbSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBlbnYpLiBVc2UgcGFydGlhbCBVUkxzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGhhdmUgYSBwYXJ0aWFsIFVSTCB0byBjb21wbGV0ZTogdXNlIHByb3ZpZGVkIGVuZHBvaW50IHR5cGUgdG8gZGV0ZXJtaW5lIGhvdyB0byBjb21wbGV0ZSB1cmwuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIGVuZHBvaW50VHlwZSBpZiBub3QgcHJvdmlkZWQgaXMgb3JpZ2luLiBUT0RPIE1HQTogcnVsZSB0byBkaXNjdXNzLCBoZXJlIGZvciByZXRyby1jb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludFR5cGUgPSBlbmRwb2ludFR5cGUgfHwgRW5kcG9pbnRUeXBlRW51bS5DdXJyZW50RG9tYWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50VHlwZSA9PT0gRW5kcG9pbnRUeXBlRW51bS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLndhcm4oJ1BhcnRpYWwgdXJsIHByb3ZpZGVkIGZvciBhIGNhbGwgd2l0aCBlbmRwb2ludFR5cGUgZmxhZ2dlZCBhcyBcXCdFeHRlcm5hbFxcJzogdGhlIGNhbGwgd2lsbCBwcm9iYWJseSBmYWlsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IG1vZGlmeSBwcm92aWRlZCB1cmwgaWYgZXh0ZXJuYWwgKHdlIGNhbm5vdCBrbm93IGhvdyB0byBjb21wbGV0ZSBpdCwgZXZlbiBpZiBwYXJ0aWFsKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmRwb2ludFR5cGUgPT09IEVuZHBvaW50VHlwZUVudW0uQ3VycmVudERvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHRoaXMuZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGFsbCBvdGhlciBlbmRwb2ludFR5cGVzOiBjb21wdXRlIFVSTCBhcyBhIGNvbWJpbmF0aW9uIG9mIGJhc2VVUkwgJiBzdWZmaXggaWYgcHJlc2VudCwgYXMgcHJvdmlkZWQgYnkgc2VydmVyLWNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmx1ZXNreUFqYXhDbGllbnRDb25maWcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignRXhwZWN0ZWQgZW5kcG9pbnRDb25maWd1cmF0aW9uRGljdGlvbm5hcnkgcHJvdmlkZWQgYnV0IG5vbmUgZm91bmQuIEFib3J0aW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50Q29uZmlnID0gdGhpcy5ibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeVtlbmRwb2ludFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRwb2ludENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIkVuZHBvaW50VHlwZSAnXCIgKyBFbmRwb2ludFR5cGVFbnVtW2VuZHBvaW50VHlwZV0gKyBcIicgaXMgbm90ICdFeHRlcm5hbCcgb3IgJ0N1cnJlbnREb21haW4nLCBleHBlY3RlZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50Q29uZmlndXJhdGlvbiBwcm92aWRlZCBpbiBibHVlc2t5QWpheENsaWVudENvbmZpZy5lbmRwb2ludENvbmZpZ3VyYXRpb25EaWN0aW9ubmFyeSBidXQgbm9uZSBmb3VuZC4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGVuZHBvaW50Q29uZmlnLmVuZHBvaW50QmFzZVVSTCArIChlbmRwb2ludENvbmZpZy5lbmRwb2ludFN1ZmZpeCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaG93IHRvIGhhbmRsZSBPTSBhcHBzIGV4dGVybmFsIGNhbGxzIHdpdGhvdXQgc2Vzc2lvbiBwcm92aWRlZCA/IHdpbGwgcmVzdWx0IGluIGEgcmVkaXJlY3QgYW5kIGNhbGwgbWF5IGZhaWwgP1xuICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgMSkgPT09ICcvJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxGcmFnbWVudEVuZHNXaXRoU2xhc2ggPSBiYXNlVXJsLnNsaWNlKGJhc2VVcmwubGVuZ3RoIC0gMSwgYmFzZVVybC5sZW5ndGgpID09PSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIC8vYmFzZWQgb24gc3RhcnRpbmcvdHJhaWxpbmcgc2xhc2hlcywgcmV0dXJuIGZ1bGwgdXJsLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsYXN0ICcvJyBvbiBiYXNlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybC5zbGljZSgwLCBiYXNlVXJsLmxlbmd0aCAtIDEpICsgdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgJy8nICsgdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChiYXNlVXJsRnJhZ21lbnRFbmRzV2l0aFNsYXNoICYmICF1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICghYmFzZVVybEZyYWdtZW50RW5kc1dpdGhTbGFzaCAmJiB1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgKiBNYWluIGNhbGxlciB0aGF0IGFsbCB3cmFwcGVyIGNhbGxzIChnZXQsIGRlbGV0ZSwgcG9zdCwgcHV0KSBtdXN0IHVzZSB0byBzaGFyZSBjb21tb24gYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuYWpheCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIHN1cmUgZ2V0Q29uZmlnIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSBfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChtZXRob2QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFySHR0cENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2Vzcyhjb25maWcpLCBfdGhpcy5vbkVycm9yKGNvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHVucm9idXN0LCBuZWVkcyBzb2xpZCByZWZhY3RvIHRvIG1ha2UgaXQgbW9yZSBnZW5lcmljIHdoZW4gb24gb3JpZ2luIGRvbWFpbiAhXG4gICAgICAgICAgICAgICAgQmx1ZXNreUh0dHBXcmFwcGVyLnByb3RvdHlwZS5nZXRVcmxQYXRoID0gZnVuY3Rpb24gKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc1JlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsQXNwQXBwc1JlZ2V4ID0gLyhcXC9cXHcrKVxcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyICYmIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICBCbHVlc2t5SHR0cFdyYXBwZXIucHJvdG90eXBlLmdldEN1cnJlbnRTZXNzaW9uSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleHBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmVjb2duaXplZCBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsIGxvY2F0aW9uIHRvIHJldHJpZXZlIHNlc3Npb25JRC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlc3Npb25JRCBpbiBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1RvbyBtYW55IG1hdGNoZXMgZm91bmQgZm9yIHRoZSBzZXNzaW9uSUQgc2VhcmNoIGluIHRoZSBjdXJyZW50IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUcmltIHRoZSBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciB0byByZXR1cm4gb25seSB0aGUgZmlsZW5hbWUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEJsdWVza3lIdHRwV3JhcHBlci5wcm90b3R5cGUuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyLnNwbGl0KCc7JylbMV0udHJpbSgpLnNwbGl0KCc9JylbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJsdWVza3lIdHRwV3JhcHBlcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBzZXJ2aWNlcy5CbHVlc2t5SHR0cFdyYXBwZXIgPSBCbHVlc2t5SHR0cFdyYXBwZXI7XG4gICAgICAgIH0pKHNlcnZpY2VzID0gY29yZS5zZXJ2aWNlcyB8fCAoY29yZS5zZXJ2aWNlcyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
